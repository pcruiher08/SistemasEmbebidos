
HumbertoPavlo_P8.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002058  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000043c  20000000  00002058  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00004080  2000043c  00002494  0002043c  2**2
                  ALLOC
  3 .stack        00002004  200044bc  00006514  0002043c  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  0002043c  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020464  2**0
                  CONTENTS, READONLY
  6 .debug_info   00013699  00000000  00000000  000204bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001c25  00000000  00000000  00033b56  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000617a  00000000  00000000  0003577b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000005b0  00000000  00000000  0003b8f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000798  00000000  00000000  0003bea5  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  000119c4  00000000  00000000  0003c63d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000050c7  00000000  00000000  0004e001  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00079f64  00000000  00000000  000530c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001164  00000000  00000000  000cd02c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	c0 64 00 20 19 01 00 00 15 01 00 00 15 01 00 00     .d. ............
	...
      2c:	15 01 00 00 00 00 00 00 00 00 00 00 e1 08 00 00     ................
      3c:	25 09 00 00 15 01 00 00 15 01 00 00 15 01 00 00     %...............
      4c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      5c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      6c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      7c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      8c:	15 01 00 00 15 01 00 00 00 00 00 00 00 00 00 00     ................
      9c:	15 01 00 00 15 01 00 00 15 01 00 00 15 01 00 00     ................
      ac:	15 01 00 00 00 00 00 00                             ........

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	2000043c 	.word	0x2000043c
      d4:	00000000 	.word	0x00000000
      d8:	00002058 	.word	0x00002058

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	20000440 	.word	0x20000440
     108:	00002058 	.word	0x00002058
     10c:	00002058 	.word	0x00002058
     110:	00000000 	.word	0x00000000

00000114 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     114:	e7fe      	b.n	114 <Dummy_Handler>
	...

00000118 <Reset_Handler>:
{
     118:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
     11a:	4a2a      	ldr	r2, [pc, #168]	; (1c4 <Reset_Handler+0xac>)
     11c:	4b2a      	ldr	r3, [pc, #168]	; (1c8 <Reset_Handler+0xb0>)
     11e:	429a      	cmp	r2, r3
     120:	d011      	beq.n	146 <Reset_Handler+0x2e>
                for (; pDest < &_erelocate;) {
     122:	001a      	movs	r2, r3
     124:	4b29      	ldr	r3, [pc, #164]	; (1cc <Reset_Handler+0xb4>)
     126:	429a      	cmp	r2, r3
     128:	d20d      	bcs.n	146 <Reset_Handler+0x2e>
     12a:	4a29      	ldr	r2, [pc, #164]	; (1d0 <Reset_Handler+0xb8>)
     12c:	3303      	adds	r3, #3
     12e:	1a9b      	subs	r3, r3, r2
     130:	089b      	lsrs	r3, r3, #2
     132:	3301      	adds	r3, #1
     134:	009b      	lsls	r3, r3, #2
     136:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
     138:	4823      	ldr	r0, [pc, #140]	; (1c8 <Reset_Handler+0xb0>)
     13a:	4922      	ldr	r1, [pc, #136]	; (1c4 <Reset_Handler+0xac>)
     13c:	588c      	ldr	r4, [r1, r2]
     13e:	5084      	str	r4, [r0, r2]
     140:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     142:	429a      	cmp	r2, r3
     144:	d1fa      	bne.n	13c <Reset_Handler+0x24>
        for (pDest = &_szero; pDest < &_ezero;) {
     146:	4a23      	ldr	r2, [pc, #140]	; (1d4 <Reset_Handler+0xbc>)
     148:	4b23      	ldr	r3, [pc, #140]	; (1d8 <Reset_Handler+0xc0>)
     14a:	429a      	cmp	r2, r3
     14c:	d20a      	bcs.n	164 <Reset_Handler+0x4c>
     14e:	43d3      	mvns	r3, r2
     150:	4921      	ldr	r1, [pc, #132]	; (1d8 <Reset_Handler+0xc0>)
     152:	185b      	adds	r3, r3, r1
     154:	2103      	movs	r1, #3
     156:	438b      	bics	r3, r1
     158:	3304      	adds	r3, #4
     15a:	189b      	adds	r3, r3, r2
                *pDest++ = 0;
     15c:	2100      	movs	r1, #0
     15e:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
     160:	4293      	cmp	r3, r2
     162:	d1fc      	bne.n	15e <Reset_Handler+0x46>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     164:	4a1d      	ldr	r2, [pc, #116]	; (1dc <Reset_Handler+0xc4>)
     166:	21ff      	movs	r1, #255	; 0xff
     168:	4b1d      	ldr	r3, [pc, #116]	; (1e0 <Reset_Handler+0xc8>)
     16a:	438b      	bics	r3, r1
     16c:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
     16e:	39fd      	subs	r1, #253	; 0xfd
     170:	2390      	movs	r3, #144	; 0x90
     172:	005b      	lsls	r3, r3, #1
     174:	4a1b      	ldr	r2, [pc, #108]	; (1e4 <Reset_Handler+0xcc>)
     176:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
     178:	4a1b      	ldr	r2, [pc, #108]	; (1e8 <Reset_Handler+0xd0>)
     17a:	78d3      	ldrb	r3, [r2, #3]
     17c:	2503      	movs	r5, #3
     17e:	43ab      	bics	r3, r5
     180:	2402      	movs	r4, #2
     182:	4323      	orrs	r3, r4
     184:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
     186:	78d3      	ldrb	r3, [r2, #3]
     188:	270c      	movs	r7, #12
     18a:	43bb      	bics	r3, r7
     18c:	2608      	movs	r6, #8
     18e:	4333      	orrs	r3, r6
     190:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
     192:	4b16      	ldr	r3, [pc, #88]	; (1ec <Reset_Handler+0xd4>)
     194:	7b98      	ldrb	r0, [r3, #14]
     196:	2230      	movs	r2, #48	; 0x30
     198:	4390      	bics	r0, r2
     19a:	2220      	movs	r2, #32
     19c:	4310      	orrs	r0, r2
     19e:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
     1a0:	7b99      	ldrb	r1, [r3, #14]
     1a2:	43b9      	bics	r1, r7
     1a4:	4331      	orrs	r1, r6
     1a6:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
     1a8:	7b9a      	ldrb	r2, [r3, #14]
     1aa:	43aa      	bics	r2, r5
     1ac:	4322      	orrs	r2, r4
     1ae:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
     1b0:	4a0f      	ldr	r2, [pc, #60]	; (1f0 <Reset_Handler+0xd8>)
     1b2:	6853      	ldr	r3, [r2, #4]
     1b4:	2180      	movs	r1, #128	; 0x80
     1b6:	430b      	orrs	r3, r1
     1b8:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     1ba:	4b0e      	ldr	r3, [pc, #56]	; (1f4 <Reset_Handler+0xdc>)
     1bc:	4798      	blx	r3
        main();
     1be:	4b0e      	ldr	r3, [pc, #56]	; (1f8 <Reset_Handler+0xe0>)
     1c0:	4798      	blx	r3
     1c2:	e7fe      	b.n	1c2 <Reset_Handler+0xaa>
     1c4:	00002058 	.word	0x00002058
     1c8:	20000000 	.word	0x20000000
     1cc:	2000043c 	.word	0x2000043c
     1d0:	20000004 	.word	0x20000004
     1d4:	2000043c 	.word	0x2000043c
     1d8:	200044bc 	.word	0x200044bc
     1dc:	e000ed00 	.word	0xe000ed00
     1e0:	00000000 	.word	0x00000000
     1e4:	41007000 	.word	0x41007000
     1e8:	41005000 	.word	0x41005000
     1ec:	41004800 	.word	0x41004800
     1f0:	41004000 	.word	0x41004000
     1f4:	00001c91 	.word	0x00001c91
     1f8:	00000445 	.word	0x00000445

000001fc <SystemInit>:
 *         Initialize the System and update the SystemCoreClock variable.
 */
void SystemInit(void)
{
        // Keep the default device state after reset
        SystemCoreClock = __SYSTEM_CLOCK;
     1fc:	4a01      	ldr	r2, [pc, #4]	; (204 <SystemInit+0x8>)
     1fe:	4b02      	ldr	r3, [pc, #8]	; (208 <SystemInit+0xc>)
     200:	601a      	str	r2, [r3, #0]
        return;
}
     202:	4770      	bx	lr
     204:	000f4240 	.word	0x000f4240
     208:	20000000 	.word	0x20000000

0000020c <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     20c:	b570      	push	{r4, r5, r6, lr}
     20e:	0004      	movs	r4, r0
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     210:	4b2a      	ldr	r3, [pc, #168]	; (2bc <pvPortMalloc+0xb0>)
     212:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     214:	4b2a      	ldr	r3, [pc, #168]	; (2c0 <pvPortMalloc+0xb4>)
     216:	689b      	ldr	r3, [r3, #8]
     218:	2b00      	cmp	r3, #0
     21a:	d011      	beq.n	240 <pvPortMalloc+0x34>
void *pvReturn = NULL;
     21c:	2500      	movs	r5, #0
			xHeapHasBeenInitialised = pdTRUE;
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     21e:	2c00      	cmp	r4, #0
     220:	d046      	beq.n	2b0 <pvPortMalloc+0xa4>
		{
			xWantedSize += heapSTRUCT_SIZE;
     222:	0020      	movs	r0, r4
     224:	3008      	adds	r0, #8

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
     226:	0743      	lsls	r3, r0, #29
     228:	d002      	beq.n	230 <pvPortMalloc+0x24>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
     22a:	2307      	movs	r3, #7
     22c:	4398      	bics	r0, r3
     22e:	3008      	adds	r0, #8
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     230:	1e43      	subs	r3, r0, #1
     232:	4a24      	ldr	r2, [pc, #144]	; (2c4 <pvPortMalloc+0xb8>)
void *pvReturn = NULL;
     234:	2500      	movs	r5, #0
		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     236:	4293      	cmp	r3, r2
     238:	d83a      	bhi.n	2b0 <pvPortMalloc+0xa4>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     23a:	4921      	ldr	r1, [pc, #132]	; (2c0 <pvPortMalloc+0xb4>)
     23c:	680b      	ldr	r3, [r1, #0]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     23e:	e013      	b.n	268 <pvPortMalloc+0x5c>
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     240:	491f      	ldr	r1, [pc, #124]	; (2c0 <pvPortMalloc+0xb4>)
     242:	000b      	movs	r3, r1
     244:	3314      	adds	r3, #20
     246:	2207      	movs	r2, #7
     248:	4393      	bics	r3, r2

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     24a:	600b      	str	r3, [r1, #0]
	xStart.xBlockSize = ( size_t ) 0;
     24c:	2500      	movs	r5, #0
     24e:	604d      	str	r5, [r1, #4]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     250:	4a1d      	ldr	r2, [pc, #116]	; (2c8 <pvPortMalloc+0xbc>)
     252:	481e      	ldr	r0, [pc, #120]	; (2cc <pvPortMalloc+0xc0>)
     254:	6110      	str	r0, [r2, #16]
	xEnd.pxNextFreeBlock = NULL;
     256:	60d5      	str	r5, [r2, #12]

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     258:	6058      	str	r0, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     25a:	320c      	adds	r2, #12
     25c:	601a      	str	r2, [r3, #0]
			xHeapHasBeenInitialised = pdTRUE;
     25e:	2301      	movs	r3, #1
     260:	608b      	str	r3, [r1, #8]
     262:	e7db      	b.n	21c <pvPortMalloc+0x10>
     264:	0019      	movs	r1, r3
				pxBlock = pxBlock->pxNextFreeBlock;
     266:	0013      	movs	r3, r2
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     268:	685a      	ldr	r2, [r3, #4]
     26a:	4290      	cmp	r0, r2
     26c:	d902      	bls.n	274 <pvPortMalloc+0x68>
     26e:	681a      	ldr	r2, [r3, #0]
     270:	2a00      	cmp	r2, #0
     272:	d1f7      	bne.n	264 <pvPortMalloc+0x58>
			if( pxBlock != &xEnd )
     274:	4a14      	ldr	r2, [pc, #80]	; (2c8 <pvPortMalloc+0xbc>)
     276:	320c      	adds	r2, #12
     278:	4293      	cmp	r3, r2
     27a:	d01d      	beq.n	2b8 <pvPortMalloc+0xac>
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     27c:	680d      	ldr	r5, [r1, #0]
     27e:	3508      	adds	r5, #8
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     280:	681a      	ldr	r2, [r3, #0]
     282:	600a      	str	r2, [r1, #0]
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     284:	685a      	ldr	r2, [r3, #4]
     286:	1a12      	subs	r2, r2, r0
     288:	2a10      	cmp	r2, #16
     28a:	d90c      	bls.n	2a6 <pvPortMalloc+0x9a>
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     28c:	181c      	adds	r4, r3, r0
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     28e:	6062      	str	r2, [r4, #4]
					pxBlock->xBlockSize = xWantedSize;
     290:	6058      	str	r0, [r3, #4]
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     292:	6860      	ldr	r0, [r4, #4]
     294:	490a      	ldr	r1, [pc, #40]	; (2c0 <pvPortMalloc+0xb4>)
     296:	e000      	b.n	29a <pvPortMalloc+0x8e>
     298:	0011      	movs	r1, r2
     29a:	680a      	ldr	r2, [r1, #0]
     29c:	6856      	ldr	r6, [r2, #4]
     29e:	42b0      	cmp	r0, r6
     2a0:	d8fa      	bhi.n	298 <pvPortMalloc+0x8c>
     2a2:	6022      	str	r2, [r4, #0]
     2a4:	600c      	str	r4, [r1, #0]
				xFreeBytesRemaining -= pxBlock->xBlockSize;
     2a6:	4a0a      	ldr	r2, [pc, #40]	; (2d0 <pvPortMalloc+0xc4>)
     2a8:	685b      	ldr	r3, [r3, #4]
     2aa:	6811      	ldr	r1, [r2, #0]
     2ac:	1acb      	subs	r3, r1, r3
     2ae:	6013      	str	r3, [r2, #0]
	( void ) xTaskResumeAll();
     2b0:	4b08      	ldr	r3, [pc, #32]	; (2d4 <pvPortMalloc+0xc8>)
     2b2:	4798      	blx	r3
}
     2b4:	0028      	movs	r0, r5
     2b6:	bd70      	pop	{r4, r5, r6, pc}
void *pvReturn = NULL;
     2b8:	2500      	movs	r5, #0
     2ba:	e7f9      	b.n	2b0 <pvPortMalloc+0xa4>
     2bc:	00001375 	.word	0x00001375
     2c0:	20000458 	.word	0x20000458
     2c4:	00003e76 	.word	0x00003e76
     2c8:	200042d8 	.word	0x200042d8
     2cc:	00003e78 	.word	0x00003e78
     2d0:	20000004 	.word	0x20000004
     2d4:	000014a1 	.word	0x000014a1

000002d8 <vPortFree>:
{
     2d8:	b570      	push	{r4, r5, r6, lr}
     2da:	1e04      	subs	r4, r0, #0
	if( pv != NULL )
     2dc:	d016      	beq.n	30c <vPortFree+0x34>
		puc -= heapSTRUCT_SIZE;
     2de:	0005      	movs	r5, r0
     2e0:	3d08      	subs	r5, #8
		vTaskSuspendAll();
     2e2:	4b0b      	ldr	r3, [pc, #44]	; (310 <vPortFree+0x38>)
     2e4:	4798      	blx	r3
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     2e6:	6869      	ldr	r1, [r5, #4]
     2e8:	4a0a      	ldr	r2, [pc, #40]	; (314 <vPortFree+0x3c>)
     2ea:	e000      	b.n	2ee <vPortFree+0x16>
     2ec:	001a      	movs	r2, r3
     2ee:	6813      	ldr	r3, [r2, #0]
     2f0:	6858      	ldr	r0, [r3, #4]
     2f2:	4281      	cmp	r1, r0
     2f4:	d8fa      	bhi.n	2ec <vPortFree+0x14>
     2f6:	3c08      	subs	r4, #8
     2f8:	6023      	str	r3, [r4, #0]
     2fa:	6015      	str	r5, [r2, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
     2fc:	4a06      	ldr	r2, [pc, #24]	; (318 <vPortFree+0x40>)
     2fe:	6863      	ldr	r3, [r4, #4]
     300:	6811      	ldr	r1, [r2, #0]
     302:	468c      	mov	ip, r1
     304:	4463      	add	r3, ip
     306:	6013      	str	r3, [r2, #0]
		( void ) xTaskResumeAll();
     308:	4b04      	ldr	r3, [pc, #16]	; (31c <vPortFree+0x44>)
     30a:	4798      	blx	r3
}
     30c:	bd70      	pop	{r4, r5, r6, pc}
     30e:	46c0      	nop			; (mov r8, r8)
     310:	00001375 	.word	0x00001375
     314:	20000458 	.word	0x20000458
     318:	20000004 	.word	0x20000004
     31c:	000014a1 	.word	0x000014a1

00000320 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     320:	0003      	movs	r3, r0
     322:	3308      	adds	r3, #8
     324:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     326:	2201      	movs	r2, #1
     328:	4252      	negs	r2, r2
     32a:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     32c:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     32e:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     330:	2300      	movs	r3, #0
     332:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     334:	4770      	bx	lr

00000336 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     336:	2300      	movs	r3, #0
     338:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     33a:	4770      	bx	lr

0000033c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
     33c:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     33e:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     340:	689a      	ldr	r2, [r3, #8]
     342:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     344:	689a      	ldr	r2, [r3, #8]
     346:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
     348:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     34a:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     34c:	6803      	ldr	r3, [r0, #0]
     34e:	3301      	adds	r3, #1
     350:	6003      	str	r3, [r0, #0]
}
     352:	4770      	bx	lr

00000354 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     354:	b530      	push	{r4, r5, lr}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     356:	680c      	ldr	r4, [r1, #0]
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     358:	0002      	movs	r2, r0
     35a:	3208      	adds	r2, #8
	if( xValueOfInsertion == portMAX_DELAY )
     35c:	1c63      	adds	r3, r4, #1
     35e:	d102      	bne.n	366 <vListInsert+0x12>
		pxIterator = pxList->xListEnd.pxPrevious;
     360:	6902      	ldr	r2, [r0, #16]
     362:	e004      	b.n	36e <vListInsert+0x1a>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     364:	001a      	movs	r2, r3
     366:	6853      	ldr	r3, [r2, #4]
     368:	681d      	ldr	r5, [r3, #0]
     36a:	42ac      	cmp	r4, r5
     36c:	d2fa      	bcs.n	364 <vListInsert+0x10>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     36e:	6853      	ldr	r3, [r2, #4]
     370:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     372:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
     374:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
     376:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     378:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     37a:	6803      	ldr	r3, [r0, #0]
     37c:	3301      	adds	r3, #1
     37e:	6003      	str	r3, [r0, #0]
}
     380:	bd30      	pop	{r4, r5, pc}

00000382 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     382:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     384:	6842      	ldr	r2, [r0, #4]
     386:	6881      	ldr	r1, [r0, #8]
     388:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     38a:	6882      	ldr	r2, [r0, #8]
     38c:	6841      	ldr	r1, [r0, #4]
     38e:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     390:	685a      	ldr	r2, [r3, #4]
     392:	4290      	cmp	r0, r2
     394:	d006      	beq.n	3a4 <uxListRemove+0x22>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     396:	2200      	movs	r2, #0
     398:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
     39a:	681a      	ldr	r2, [r3, #0]
     39c:	3a01      	subs	r2, #1
     39e:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
     3a0:	6818      	ldr	r0, [r3, #0]
}
     3a2:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     3a4:	6882      	ldr	r2, [r0, #8]
     3a6:	605a      	str	r2, [r3, #4]
     3a8:	e7f5      	b.n	396 <uxListRemove+0x14>
	...

000003ac <receiver_task>:
            	myprintf("\nHello World task 1 %d", i++);
            	vTaskDelay(1000);
    	}
}

void receiver_task(void *p) {
     3ac:	b570      	push	{r4, r5, r6, lr}
	while(1) {
		static uint32_t j = 0;
		if(xQueueReceive(Global_Queue_Handle, &j, 1000)){
     3ae:	4c0a      	ldr	r4, [pc, #40]	; (3d8 <receiver_task+0x2c>)
     3b0:	4d0a      	ldr	r5, [pc, #40]	; (3dc <receiver_task+0x30>)
			myprintf("Received %d\n", j);
		}else{
			myprintf("Failed to receive data from queue\n");
     3b2:	4e0b      	ldr	r6, [pc, #44]	; (3e0 <receiver_task+0x34>)
     3b4:	e002      	b.n	3bc <receiver_task+0x10>
     3b6:	0030      	movs	r0, r6
     3b8:	4b0a      	ldr	r3, [pc, #40]	; (3e4 <receiver_task+0x38>)
     3ba:	4798      	blx	r3
		if(xQueueReceive(Global_Queue_Handle, &j, 1000)){
     3bc:	22fa      	movs	r2, #250	; 0xfa
     3be:	0092      	lsls	r2, r2, #2
     3c0:	0021      	movs	r1, r4
     3c2:	6860      	ldr	r0, [r4, #4]
     3c4:	47a8      	blx	r5
     3c6:	2800      	cmp	r0, #0
     3c8:	d0f5      	beq.n	3b6 <receiver_task+0xa>
			myprintf("Received %d\n", j);
     3ca:	4b03      	ldr	r3, [pc, #12]	; (3d8 <receiver_task+0x2c>)
     3cc:	6819      	ldr	r1, [r3, #0]
     3ce:	4806      	ldr	r0, [pc, #24]	; (3e8 <receiver_task+0x3c>)
     3d0:	4b04      	ldr	r3, [pc, #16]	; (3e4 <receiver_task+0x38>)
     3d2:	4798      	blx	r3
     3d4:	e7f2      	b.n	3bc <receiver_task+0x10>
     3d6:	46c0      	nop			; (mov r8, r8)
     3d8:	200042ec 	.word	0x200042ec
     3dc:	00000e51 	.word	0x00000e51
     3e0:	00001f58 	.word	0x00001f58
     3e4:	0000059d 	.word	0x0000059d
     3e8:	00001f48 	.word	0x00001f48

000003ec <sender_task>:
		}
	}
}


void sender_task(void *p) {
     3ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	while(1) {
		static uint32_t i = 0;
		myprintf("Send %d to receiver task\n", i);
     3ee:	4e0f      	ldr	r6, [pc, #60]	; (42c <sender_task+0x40>)
     3f0:	4d0f      	ldr	r5, [pc, #60]	; (430 <sender_task+0x44>)
		if (! xQueueSend(Global_Queue_Handle, &i, 1000)){
     3f2:	0034      	movs	r4, r6
     3f4:	3408      	adds	r4, #8
     3f6:	e007      	b.n	408 <sender_task+0x1c>
			myprintf("Failed to receive data from queue\n");
		}
		i++;
     3f8:	4a0c      	ldr	r2, [pc, #48]	; (42c <sender_task+0x40>)
     3fa:	6893      	ldr	r3, [r2, #8]
     3fc:	3301      	adds	r3, #1
     3fe:	6093      	str	r3, [r2, #8]
		vTaskDelay(2000);
     400:	20fa      	movs	r0, #250	; 0xfa
     402:	00c0      	lsls	r0, r0, #3
     404:	4b0b      	ldr	r3, [pc, #44]	; (434 <sender_task+0x48>)
     406:	4798      	blx	r3
		myprintf("Send %d to receiver task\n", i);
     408:	68b1      	ldr	r1, [r6, #8]
     40a:	0028      	movs	r0, r5
     40c:	4b0a      	ldr	r3, [pc, #40]	; (438 <sender_task+0x4c>)
     40e:	4798      	blx	r3
		if (! xQueueSend(Global_Queue_Handle, &i, 1000)){
     410:	2300      	movs	r3, #0
     412:	22fa      	movs	r2, #250	; 0xfa
     414:	0092      	lsls	r2, r2, #2
     416:	0021      	movs	r1, r4
     418:	6870      	ldr	r0, [r6, #4]
     41a:	4f08      	ldr	r7, [pc, #32]	; (43c <sender_task+0x50>)
     41c:	47b8      	blx	r7
     41e:	2800      	cmp	r0, #0
     420:	d1ea      	bne.n	3f8 <sender_task+0xc>
			myprintf("Failed to receive data from queue\n");
     422:	4807      	ldr	r0, [pc, #28]	; (440 <sender_task+0x54>)
     424:	4b04      	ldr	r3, [pc, #16]	; (438 <sender_task+0x4c>)
     426:	4798      	blx	r3
     428:	e7e6      	b.n	3f8 <sender_task+0xc>
     42a:	46c0      	nop			; (mov r8, r8)
     42c:	200042ec 	.word	0x200042ec
     430:	00001f7c 	.word	0x00001f7c
     434:	00001595 	.word	0x00001595
     438:	0000059d 	.word	0x0000059d
     43c:	00000bf5 	.word	0x00000bf5
     440:	00001f58 	.word	0x00001f58

00000444 <main>:
  }
}


int main()
{
     444:	b5f0      	push	{r4, r5, r6, r7, lr}
     446:	b083      	sub	sp, #12
  SystemInit();
     448:	4b1c      	ldr	r3, [pc, #112]	; (4bc <main+0x78>)
     44a:	4798      	blx	r3
  /* Switch to 8MHz clock (disable prescaler) */
  SYSCTRL->OSC8M.bit.PRESC = 0;	
     44c:	4a1c      	ldr	r2, [pc, #112]	; (4c0 <main+0x7c>)
     44e:	6a13      	ldr	r3, [r2, #32]
     450:	491c      	ldr	r1, [pc, #112]	; (4c4 <main+0x80>)
     452:	400b      	ands	r3, r1
     454:	6213      	str	r3, [r2, #32]
  initUART();
     456:	4b1c      	ldr	r3, [pc, #112]	; (4c8 <main+0x84>)
     458:	4798      	blx	r3

  PORT->Group[0].PINCFG[PIN_PA14].reg = 0x02; 
     45a:	4b1c      	ldr	r3, [pc, #112]	; (4cc <main+0x88>)
     45c:	2202      	movs	r2, #2
     45e:	214e      	movs	r1, #78	; 0x4e
     460:	545a      	strb	r2, [r3, r1]
  PORT->Group[0].PINCFG[PIN_PA09].reg = 0x02; 
     462:	3905      	subs	r1, #5
     464:	545a      	strb	r2, [r3, r1]
	PORT->Group[0].PINCFG[PIN_PA08].reg = 0x02; 
     466:	3901      	subs	r1, #1
     468:	545a      	strb	r2, [r3, r1]
	PORT->Group[0].PINCFG[PIN_PA15].reg = 0x02; 
     46a:	3107      	adds	r1, #7
     46c:	545a      	strb	r2, [r3, r1]

	PORT->Group[0].DIRCLR.reg = PORT_PA14; 
     46e:	2280      	movs	r2, #128	; 0x80
     470:	01d2      	lsls	r2, r2, #7
     472:	605a      	str	r2, [r3, #4]
	PORT->Group[0].DIRCLR.reg = PORT_PA09; 
     474:	2480      	movs	r4, #128	; 0x80
     476:	00a4      	lsls	r4, r4, #2
     478:	605c      	str	r4, [r3, #4]
	PORT->Group[0].DIRCLR.reg = PORT_PA08; 
     47a:	2280      	movs	r2, #128	; 0x80
     47c:	0052      	lsls	r2, r2, #1
     47e:	605a      	str	r2, [r3, #4]
	PORT->Group[0].DIRCLR.reg = PORT_PA15; 
     480:	2280      	movs	r2, #128	; 0x80
     482:	0212      	lsls	r2, r2, #8
     484:	605a      	str	r2, [r3, #4]
	Global_Queue_Handle = xQueueCreate(3, sizeof(int));
     486:	2200      	movs	r2, #0
     488:	394b      	subs	r1, #75	; 0x4b
     48a:	2003      	movs	r0, #3
     48c:	4b10      	ldr	r3, [pc, #64]	; (4d0 <main+0x8c>)
     48e:	4798      	blx	r3
     490:	4b10      	ldr	r3, [pc, #64]	; (4d4 <main+0x90>)
     492:	6058      	str	r0, [r3, #4]
            	NULL,           	    
            	myTASK_TASK_PRIORITY,   
            	NULL );     
  */
  
  xTaskCreate(sender_task,"sender",512,NULL,myTASK_TASK_PRIORITY,NULL );         	    
     494:	2700      	movs	r7, #0
     496:	9701      	str	r7, [sp, #4]
     498:	2601      	movs	r6, #1
     49a:	9600      	str	r6, [sp, #0]
     49c:	2300      	movs	r3, #0
     49e:	0022      	movs	r2, r4
     4a0:	490d      	ldr	r1, [pc, #52]	; (4d8 <main+0x94>)
     4a2:	480e      	ldr	r0, [pc, #56]	; (4dc <main+0x98>)
     4a4:	4d0e      	ldr	r5, [pc, #56]	; (4e0 <main+0x9c>)
     4a6:	47a8      	blx	r5
  
  xTaskCreate(receiver_task,"receiver",512,NULL,myTASK_TASK_PRIORITY,NULL );         	      	    
     4a8:	9701      	str	r7, [sp, #4]
     4aa:	9600      	str	r6, [sp, #0]
     4ac:	2300      	movs	r3, #0
     4ae:	0022      	movs	r2, r4
     4b0:	490c      	ldr	r1, [pc, #48]	; (4e4 <main+0xa0>)
     4b2:	480d      	ldr	r0, [pc, #52]	; (4e8 <main+0xa4>)
     4b4:	47a8      	blx	r5
    
  vTaskStartScheduler();
     4b6:	4b0d      	ldr	r3, [pc, #52]	; (4ec <main+0xa8>)
     4b8:	4798      	blx	r3
     4ba:	e7fe      	b.n	4ba <main+0x76>
     4bc:	000001fd 	.word	0x000001fd
     4c0:	40000800 	.word	0x40000800
     4c4:	fffffcff 	.word	0xfffffcff
     4c8:	00001bf5 	.word	0x00001bf5
     4cc:	41004400 	.word	0x41004400
     4d0:	00000ba9 	.word	0x00000ba9
     4d4:	200042ec 	.word	0x200042ec
     4d8:	00001fcc 	.word	0x00001fcc
     4dc:	000003ed 	.word	0x000003ed
     4e0:	00001139 	.word	0x00001139
     4e4:	00001fd4 	.word	0x00001fd4
     4e8:	000003ad 	.word	0x000003ad
     4ec:	0000130d 	.word	0x0000130d

000004f0 <out>:
    //return 0;
//}


static void out(char c) {
    *bf++ = c;
     4f0:	4a02      	ldr	r2, [pc, #8]	; (4fc <out+0xc>)
     4f2:	6813      	ldr	r3, [r2, #0]
     4f4:	1c59      	adds	r1, r3, #1
     4f6:	6011      	str	r1, [r2, #0]
     4f8:	7018      	strb	r0, [r3, #0]
    }
     4fa:	4770      	bx	lr
     4fc:	20004300 	.word	0x20004300

00000500 <outDgt>:

static void outDgt(char dgt) {
     500:	b510      	push	{r4, lr}
	out(dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10));
     502:	2330      	movs	r3, #48	; 0x30
     504:	2809      	cmp	r0, #9
     506:	d905      	bls.n	514 <outDgt+0x14>
     508:	4b06      	ldr	r3, [pc, #24]	; (524 <outDgt+0x24>)
     50a:	791a      	ldrb	r2, [r3, #4]
     50c:	2337      	movs	r3, #55	; 0x37
     50e:	2a00      	cmp	r2, #0
     510:	d100      	bne.n	514 <outDgt+0x14>
     512:	3320      	adds	r3, #32
     514:	1818      	adds	r0, r3, r0
     516:	b2c0      	uxtb	r0, r0
     518:	4b03      	ldr	r3, [pc, #12]	; (528 <outDgt+0x28>)
     51a:	4798      	blx	r3
	zs=1;
     51c:	2201      	movs	r2, #1
     51e:	4b01      	ldr	r3, [pc, #4]	; (524 <outDgt+0x24>)
     520:	715a      	strb	r2, [r3, #5]
    }
     522:	bd10      	pop	{r4, pc}
     524:	20004300 	.word	0x20004300
     528:	000004f1 	.word	0x000004f1

0000052c <divOut>:
	
static void divOut(unsigned int div) {
     52c:	b510      	push	{r4, lr}
    unsigned char dgt=0;
	num &= 0xffff; // just for testing the code  with 32 bit ints
     52e:	4b0e      	ldr	r3, [pc, #56]	; (568 <divOut+0x3c>)
     530:	891a      	ldrh	r2, [r3, #8]
     532:	609a      	str	r2, [r3, #8]
	while (num>=div) {
     534:	4282      	cmp	r2, r0
     536:	d310      	bcc.n	55a <divOut+0x2e>
     538:	2300      	movs	r3, #0
		num -= div;
     53a:	1a12      	subs	r2, r2, r0
		dgt++;
     53c:	3301      	adds	r3, #1
     53e:	b2db      	uxtb	r3, r3
	while (num>=div) {
     540:	4290      	cmp	r0, r2
     542:	d9fa      	bls.n	53a <divOut+0xe>
     544:	4908      	ldr	r1, [pc, #32]	; (568 <divOut+0x3c>)
     546:	608a      	str	r2, [r1, #8]
		}
	if (zs || dgt>0) 
     548:	794a      	ldrb	r2, [r1, #5]
     54a:	2a00      	cmp	r2, #0
     54c:	d101      	bne.n	552 <divOut+0x26>
     54e:	2b00      	cmp	r3, #0
     550:	d002      	beq.n	558 <divOut+0x2c>
		outDgt(dgt);
     552:	0018      	movs	r0, r3
     554:	4b05      	ldr	r3, [pc, #20]	; (56c <divOut+0x40>)
     556:	4798      	blx	r3
    }	
     558:	bd10      	pop	{r4, pc}
	if (zs || dgt>0) 
     55a:	4b03      	ldr	r3, [pc, #12]	; (568 <divOut+0x3c>)
     55c:	795b      	ldrb	r3, [r3, #5]
     55e:	2b00      	cmp	r3, #0
     560:	d0fa      	beq.n	558 <divOut+0x2c>
    unsigned char dgt=0;
     562:	2300      	movs	r3, #0
     564:	e7f5      	b.n	552 <divOut+0x26>
     566:	46c0      	nop			; (mov r8, r8)
     568:	20004300 	.word	0x20004300
     56c:	00000501 	.word	0x00000501

00000570 <myputchar>:
  if(c=='\n')
     570:	280a      	cmp	r0, #10
     572:	d008      	beq.n	586 <myputchar+0x16>
  while (!(SERCOM0->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE));
     574:	4908      	ldr	r1, [pc, #32]	; (598 <myputchar+0x28>)
     576:	2201      	movs	r2, #1
     578:	7e0b      	ldrb	r3, [r1, #24]
     57a:	4213      	tst	r3, r2
     57c:	d0fc      	beq.n	578 <myputchar+0x8>
  SERCOM0->USART.DATA.reg = s;
     57e:	b280      	uxth	r0, r0
     580:	4b05      	ldr	r3, [pc, #20]	; (598 <myputchar+0x28>)
     582:	8518      	strh	r0, [r3, #40]	; 0x28
}
     584:	4770      	bx	lr
  while (!(SERCOM0->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE));
     586:	4904      	ldr	r1, [pc, #16]	; (598 <myputchar+0x28>)
     588:	2201      	movs	r2, #1
     58a:	7e0b      	ldrb	r3, [r1, #24]
     58c:	4213      	tst	r3, r2
     58e:	d0fc      	beq.n	58a <myputchar+0x1a>
  SERCOM0->USART.DATA.reg = s;
     590:	220d      	movs	r2, #13
     592:	4b01      	ldr	r3, [pc, #4]	; (598 <myputchar+0x28>)
     594:	851a      	strh	r2, [r3, #40]	; 0x28
     596:	e7ed      	b.n	574 <myputchar+0x4>
     598:	42000800 	.word	0x42000800

0000059c <tfp_printf>:

void tfp_printf(char *fmt, ...)
	{
     59c:	b40f      	push	{r0, r1, r2, r3}
     59e:	b5f0      	push	{r4, r5, r6, r7, lr}
     5a0:	46de      	mov	lr, fp
     5a2:	4657      	mov	r7, sl
     5a4:	464e      	mov	r6, r9
     5a6:	4645      	mov	r5, r8
     5a8:	b5e0      	push	{r5, r6, r7, lr}
     5aa:	b087      	sub	sp, #28
     5ac:	ab10      	add	r3, sp, #64	; 0x40
     5ae:	cb80      	ldmia	r3!, {r7}
	va_list va;
	char ch;
	char* p;
	
	va_start(va,fmt);
     5b0:	9305      	str	r3, [sp, #20]
				while (ch>='0' && ch<='9') {
					w=(((w<<2)+w)<<1)+ch-'0';
					ch=*fmt++;
					}
				}
			bf=buf;
     5b2:	4b73      	ldr	r3, [pc, #460]	; (780 <tfp_printf+0x1e4>)
     5b4:	330c      	adds	r3, #12
     5b6:	9302      	str	r3, [sp, #8]
				case '%' :
					out('%');
				default:
					break;
				}
			*bf=0;
     5b8:	4b71      	ldr	r3, [pc, #452]	; (780 <tfp_printf+0x1e4>)
     5ba:	469a      	mov	sl, r3
			while (*bf++ && w > 0)
				w--;
			while (w-- > 0) 
				myputchar(lz ? '0' : ' ');
			while ((ch= *p++))
				myputchar(ch);
     5bc:	4b71      	ldr	r3, [pc, #452]	; (784 <tfp_printf+0x1e8>)
     5be:	4698      	mov	r8, r3
			p=bf;
     5c0:	4653      	mov	r3, sl
     5c2:	330c      	adds	r3, #12
     5c4:	9303      	str	r3, [sp, #12]
	while ((ch=*(fmt++))) {
     5c6:	e08c      	b.n	6e2 <tfp_printf+0x146>
			ch=*(fmt++);
     5c8:	787b      	ldrb	r3, [r7, #1]
			if (ch=='0') {
     5ca:	2b30      	cmp	r3, #48	; 0x30
     5cc:	d029      	beq.n	622 <tfp_printf+0x86>
			ch=*(fmt++);
     5ce:	3702      	adds	r7, #2
			char lz=0;
     5d0:	2200      	movs	r2, #0
     5d2:	4693      	mov	fp, r2
			char w=0;
     5d4:	2400      	movs	r4, #0
			if (ch>='0' && ch<='9') {
     5d6:	001a      	movs	r2, r3
     5d8:	3a30      	subs	r2, #48	; 0x30
     5da:	2a09      	cmp	r2, #9
     5dc:	d80c      	bhi.n	5f8 <tfp_printf+0x5c>
					w=(((w<<2)+w)<<1)+ch-'0';
     5de:	00a2      	lsls	r2, r4, #2
     5e0:	18a4      	adds	r4, r4, r2
     5e2:	0064      	lsls	r4, r4, #1
     5e4:	3c30      	subs	r4, #48	; 0x30
     5e6:	18e4      	adds	r4, r4, r3
     5e8:	b2e4      	uxtb	r4, r4
					ch=*fmt++;
     5ea:	1c7a      	adds	r2, r7, #1
     5ec:	783b      	ldrb	r3, [r7, #0]
     5ee:	0017      	movs	r7, r2
				while (ch>='0' && ch<='9') {
     5f0:	0019      	movs	r1, r3
     5f2:	3930      	subs	r1, #48	; 0x30
     5f4:	2909      	cmp	r1, #9
     5f6:	d9f2      	bls.n	5de <tfp_printf+0x42>
			bf=buf;
     5f8:	4a61      	ldr	r2, [pc, #388]	; (780 <tfp_printf+0x1e4>)
     5fa:	9902      	ldr	r1, [sp, #8]
     5fc:	6011      	str	r1, [r2, #0]
			zs=0;
     5fe:	2200      	movs	r2, #0
     600:	495f      	ldr	r1, [pc, #380]	; (780 <tfp_printf+0x1e4>)
     602:	714a      	strb	r2, [r1, #5]
			switch (ch) {
     604:	2b63      	cmp	r3, #99	; 0x63
     606:	d100      	bne.n	60a <tfp_printf+0x6e>
     608:	e07d      	b.n	706 <tfp_printf+0x16a>
     60a:	d80f      	bhi.n	62c <tfp_printf+0x90>
     60c:	2b25      	cmp	r3, #37	; 0x25
     60e:	d100      	bne.n	612 <tfp_printf+0x76>
     610:	e086      	b.n	720 <tfp_printf+0x184>
     612:	2b58      	cmp	r3, #88	; 0x58
     614:	d011      	beq.n	63a <tfp_printf+0x9e>
     616:	2b00      	cmp	r3, #0
     618:	d100      	bne.n	61c <tfp_printf+0x80>
     61a:	e0a6      	b.n	76a <tfp_printf+0x1ce>
			p=bf;
     61c:	4d58      	ldr	r5, [pc, #352]	; (780 <tfp_printf+0x1e4>)
     61e:	350c      	adds	r5, #12
     620:	e03c      	b.n	69c <tfp_printf+0x100>
				ch=*(fmt++);
     622:	78bb      	ldrb	r3, [r7, #2]
     624:	3703      	adds	r7, #3
				lz=1;
     626:	2201      	movs	r2, #1
     628:	4693      	mov	fp, r2
     62a:	e7d3      	b.n	5d4 <tfp_printf+0x38>
			switch (ch) {
     62c:	2b73      	cmp	r3, #115	; 0x73
     62e:	d072      	beq.n	716 <tfp_printf+0x17a>
     630:	d91b      	bls.n	66a <tfp_printf+0xce>
     632:	2b75      	cmp	r3, #117	; 0x75
     634:	d01b      	beq.n	66e <tfp_printf+0xd2>
     636:	2b78      	cmp	r3, #120	; 0x78
     638:	d1f0      	bne.n	61c <tfp_printf+0x80>
				    uc= ch=='X';
     63a:	4d51      	ldr	r5, [pc, #324]	; (780 <tfp_printf+0x1e4>)
     63c:	3b58      	subs	r3, #88	; 0x58
     63e:	4259      	negs	r1, r3
     640:	4159      	adcs	r1, r3
     642:	7129      	strb	r1, [r5, #4]
					num=va_arg(va, unsigned int);
     644:	9b05      	ldr	r3, [sp, #20]
     646:	1d1a      	adds	r2, r3, #4
     648:	9205      	str	r2, [sp, #20]
     64a:	681b      	ldr	r3, [r3, #0]
     64c:	60ab      	str	r3, [r5, #8]
					divOut(0x1000);
     64e:	2080      	movs	r0, #128	; 0x80
     650:	0140      	lsls	r0, r0, #5
     652:	4e4d      	ldr	r6, [pc, #308]	; (788 <tfp_printf+0x1ec>)
     654:	47b0      	blx	r6
					divOut(0x100);
     656:	2080      	movs	r0, #128	; 0x80
     658:	0040      	lsls	r0, r0, #1
     65a:	47b0      	blx	r6
					divOut(0x10);
     65c:	2010      	movs	r0, #16
     65e:	47b0      	blx	r6
					outDgt(num);
     660:	7a28      	ldrb	r0, [r5, #8]
     662:	4b4a      	ldr	r3, [pc, #296]	; (78c <tfp_printf+0x1f0>)
     664:	4798      	blx	r3
			p=bf;
     666:	350c      	adds	r5, #12
					break;
     668:	e018      	b.n	69c <tfp_printf+0x100>
			switch (ch) {
     66a:	2b64      	cmp	r3, #100	; 0x64
     66c:	d1d6      	bne.n	61c <tfp_printf+0x80>
					num=va_arg(va, unsigned int);
     66e:	9a05      	ldr	r2, [sp, #20]
     670:	1d11      	adds	r1, r2, #4
     672:	9105      	str	r1, [sp, #20]
     674:	6812      	ldr	r2, [r2, #0]
     676:	4942      	ldr	r1, [pc, #264]	; (780 <tfp_printf+0x1e4>)
     678:	608a      	str	r2, [r1, #8]
					if (ch=='d' && (int)num<0) {
     67a:	2b64      	cmp	r3, #100	; 0x64
     67c:	d03b      	beq.n	6f6 <tfp_printf+0x15a>
					divOut(10000);
     67e:	4844      	ldr	r0, [pc, #272]	; (790 <tfp_printf+0x1f4>)
     680:	4d41      	ldr	r5, [pc, #260]	; (788 <tfp_printf+0x1ec>)
     682:	47a8      	blx	r5
					divOut(1000);
     684:	20fa      	movs	r0, #250	; 0xfa
     686:	0080      	lsls	r0, r0, #2
     688:	47a8      	blx	r5
					divOut(100);
     68a:	2064      	movs	r0, #100	; 0x64
     68c:	47a8      	blx	r5
					divOut(10);
     68e:	200a      	movs	r0, #10
     690:	47a8      	blx	r5
					outDgt(num);
     692:	4d3b      	ldr	r5, [pc, #236]	; (780 <tfp_printf+0x1e4>)
     694:	7a28      	ldrb	r0, [r5, #8]
     696:	4b3d      	ldr	r3, [pc, #244]	; (78c <tfp_printf+0x1f0>)
     698:	4798      	blx	r3
			p=bf;
     69a:	350c      	adds	r5, #12
			*bf=0;
     69c:	2300      	movs	r3, #0
     69e:	4652      	mov	r2, sl
     6a0:	6812      	ldr	r2, [r2, #0]
     6a2:	7013      	strb	r3, [r2, #0]
			while (*bf++ && w > 0)
     6a4:	1c6b      	adds	r3, r5, #1
     6a6:	4699      	mov	r9, r3
     6a8:	4653      	mov	r3, sl
     6aa:	464a      	mov	r2, r9
     6ac:	601a      	str	r2, [r3, #0]
     6ae:	7828      	ldrb	r0, [r5, #0]
     6b0:	2800      	cmp	r0, #0
     6b2:	d055      	beq.n	760 <tfp_printf+0x1c4>
     6b4:	2c00      	cmp	r4, #0
     6b6:	d00c      	beq.n	6d2 <tfp_printf+0x136>
     6b8:	1caa      	adds	r2, r5, #2
				w--;
     6ba:	1e63      	subs	r3, r4, #1
     6bc:	b2db      	uxtb	r3, r3
			while (*bf++ && w > 0)
     6be:	0011      	movs	r1, r2
     6c0:	1e56      	subs	r6, r2, #1
     6c2:	7836      	ldrb	r6, [r6, #0]
     6c4:	2e00      	cmp	r6, #0
     6c6:	d03c      	beq.n	742 <tfp_printf+0x1a6>
     6c8:	3201      	adds	r2, #1
				w--;
     6ca:	1e1c      	subs	r4, r3, #0
			while (*bf++ && w > 0)
     6cc:	d1f5      	bne.n	6ba <tfp_printf+0x11e>
     6ce:	4b2c      	ldr	r3, [pc, #176]	; (780 <tfp_printf+0x1e4>)
     6d0:	6019      	str	r1, [r3, #0]
			while ((ch= *p++))
     6d2:	7828      	ldrb	r0, [r5, #0]
     6d4:	464d      	mov	r5, r9
				myputchar(ch);
     6d6:	47c0      	blx	r8
     6d8:	3501      	adds	r5, #1
			while ((ch= *p++))
     6da:	1e6b      	subs	r3, r5, #1
     6dc:	7818      	ldrb	r0, [r3, #0]
     6de:	2800      	cmp	r0, #0
     6e0:	d1f9      	bne.n	6d6 <tfp_printf+0x13a>
	while ((ch=*(fmt++))) {
     6e2:	7838      	ldrb	r0, [r7, #0]
     6e4:	2800      	cmp	r0, #0
     6e6:	d040      	beq.n	76a <tfp_printf+0x1ce>
		if (ch!='%') {
     6e8:	2825      	cmp	r0, #37	; 0x25
     6ea:	d100      	bne.n	6ee <tfp_printf+0x152>
     6ec:	e76c      	b.n	5c8 <tfp_printf+0x2c>
	while ((ch=*(fmt++))) {
     6ee:	3701      	adds	r7, #1
			myputchar(ch);
     6f0:	4b24      	ldr	r3, [pc, #144]	; (784 <tfp_printf+0x1e8>)
     6f2:	4798      	blx	r3
     6f4:	e7f5      	b.n	6e2 <tfp_printf+0x146>
					if (ch=='d' && (int)num<0) {
     6f6:	2a00      	cmp	r2, #0
     6f8:	dac1      	bge.n	67e <tfp_printf+0xe2>
						num = -(int)num;
     6fa:	4252      	negs	r2, r2
     6fc:	608a      	str	r2, [r1, #8]
						out('-');
     6fe:	202d      	movs	r0, #45	; 0x2d
     700:	4b24      	ldr	r3, [pc, #144]	; (794 <tfp_printf+0x1f8>)
     702:	4798      	blx	r3
     704:	e7bb      	b.n	67e <tfp_printf+0xe2>
					out((char)(va_arg(va, int)));
     706:	9b05      	ldr	r3, [sp, #20]
     708:	1d1a      	adds	r2, r3, #4
     70a:	9205      	str	r2, [sp, #20]
     70c:	7818      	ldrb	r0, [r3, #0]
     70e:	4b21      	ldr	r3, [pc, #132]	; (794 <tfp_printf+0x1f8>)
     710:	4798      	blx	r3
			p=bf;
     712:	9d03      	ldr	r5, [sp, #12]
					break;
     714:	e7c2      	b.n	69c <tfp_printf+0x100>
					p=va_arg(va, char*);
     716:	9b05      	ldr	r3, [sp, #20]
     718:	1d1a      	adds	r2, r3, #4
     71a:	9205      	str	r2, [sp, #20]
     71c:	681d      	ldr	r5, [r3, #0]
					break;
     71e:	e7bd      	b.n	69c <tfp_printf+0x100>
					out('%');
     720:	2025      	movs	r0, #37	; 0x25
     722:	4b1c      	ldr	r3, [pc, #112]	; (794 <tfp_printf+0x1f8>)
     724:	4798      	blx	r3
			p=bf;
     726:	4d16      	ldr	r5, [pc, #88]	; (780 <tfp_printf+0x1e4>)
     728:	350c      	adds	r5, #12
     72a:	e7b7      	b.n	69c <tfp_printf+0x100>
			while (w-- > 0) 
     72c:	001e      	movs	r6, r3
				myputchar(lz ? '0' : ' ');
     72e:	9801      	ldr	r0, [sp, #4]
     730:	47a0      	blx	r4
			while (w-- > 0) 
     732:	1e73      	subs	r3, r6, #1
     734:	b2db      	uxtb	r3, r3
     736:	2e00      	cmp	r6, #0
     738:	d1f8      	bne.n	72c <tfp_printf+0x190>
			while ((ch= *p++))
     73a:	7828      	ldrb	r0, [r5, #0]
     73c:	2800      	cmp	r0, #0
     73e:	d1c9      	bne.n	6d4 <tfp_printf+0x138>
     740:	e7cf      	b.n	6e2 <tfp_printf+0x146>
     742:	4a0f      	ldr	r2, [pc, #60]	; (780 <tfp_printf+0x1e4>)
     744:	6011      	str	r1, [r2, #0]
			while (w-- > 0) 
     746:	3c02      	subs	r4, #2
     748:	b2e6      	uxtb	r6, r4
     74a:	2b00      	cmp	r3, #0
     74c:	d0c2      	beq.n	6d4 <tfp_printf+0x138>
     74e:	2420      	movs	r4, #32
     750:	465b      	mov	r3, fp
     752:	2b00      	cmp	r3, #0
     754:	d000      	beq.n	758 <tfp_printf+0x1bc>
     756:	2430      	movs	r4, #48	; 0x30
     758:	b2e3      	uxtb	r3, r4
     75a:	9301      	str	r3, [sp, #4]
				myputchar(lz ? '0' : ' ');
     75c:	4c09      	ldr	r4, [pc, #36]	; (784 <tfp_printf+0x1e8>)
     75e:	e7e6      	b.n	72e <tfp_printf+0x192>
			while (w-- > 0) 
     760:	1e66      	subs	r6, r4, #1
     762:	b2f6      	uxtb	r6, r6
     764:	2c00      	cmp	r4, #0
     766:	d1f2      	bne.n	74e <tfp_printf+0x1b2>
     768:	e7bb      	b.n	6e2 <tfp_printf+0x146>
			}
		}
	abort:;
	va_end(va);
	}
     76a:	b007      	add	sp, #28
     76c:	bc3c      	pop	{r2, r3, r4, r5}
     76e:	4690      	mov	r8, r2
     770:	4699      	mov	r9, r3
     772:	46a2      	mov	sl, r4
     774:	46ab      	mov	fp, r5
     776:	bcf0      	pop	{r4, r5, r6, r7}
     778:	bc08      	pop	{r3}
     77a:	b004      	add	sp, #16
     77c:	4718      	bx	r3
     77e:	46c0      	nop			; (mov r8, r8)
     780:	20004300 	.word	0x20004300
     784:	00000571 	.word	0x00000571
     788:	0000052d 	.word	0x0000052d
     78c:	00000501 	.word	0x00000501
     790:	00002710 	.word	0x00002710
     794:	000004f1 	.word	0x000004f1

00000798 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
     798:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0UL;
     79a:	2300      	movs	r3, #0
     79c:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
     79e:	4b06      	ldr	r3, [pc, #24]	; (7b8 <prvTaskExitError+0x20>)
     7a0:	681b      	ldr	r3, [r3, #0]
     7a2:	3301      	adds	r3, #1
     7a4:	d001      	beq.n	7aa <prvTaskExitError+0x12>
     7a6:	b672      	cpsid	i
     7a8:	e7fe      	b.n	7a8 <prvTaskExitError+0x10>
	portDISABLE_INTERRUPTS();
     7aa:	b672      	cpsid	i
	while( ulDummy == 0 )
     7ac:	9b01      	ldr	r3, [sp, #4]
     7ae:	2b00      	cmp	r3, #0
     7b0:	d0fc      	beq.n	7ac <prvTaskExitError+0x14>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
     7b2:	b002      	add	sp, #8
     7b4:	4770      	bx	lr
     7b6:	46c0      	nop			; (mov r8, r8)
     7b8:	20000008 	.word	0x20000008
     7bc:	00000000 	.word	0x00000000

000007c0 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
     7c0:	4a0b      	ldr	r2, [pc, #44]	; (7f0 <pxCurrentTCBConst2>)
     7c2:	6813      	ldr	r3, [r2, #0]
     7c4:	6818      	ldr	r0, [r3, #0]
     7c6:	3020      	adds	r0, #32
     7c8:	f380 8809 	msr	PSP, r0
     7cc:	2002      	movs	r0, #2
     7ce:	f380 8814 	msr	CONTROL, r0
     7d2:	f3bf 8f6f 	isb	sy
     7d6:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
     7d8:	46ae      	mov	lr, r5
     7da:	bc08      	pop	{r3}
     7dc:	bc04      	pop	{r2}
     7de:	b662      	cpsie	i
     7e0:	4718      	bx	r3
     7e2:	46c0      	nop			; (mov r8, r8)
     7e4:	46c0      	nop			; (mov r8, r8)
     7e6:	46c0      	nop			; (mov r8, r8)
     7e8:	46c0      	nop			; (mov r8, r8)
     7ea:	46c0      	nop			; (mov r8, r8)
     7ec:	46c0      	nop			; (mov r8, r8)
     7ee:	46c0      	nop			; (mov r8, r8)

000007f0 <pxCurrentTCBConst2>:
     7f0:	200043cc 	.word	0x200043cc

000007f4 <pxPortInitialiseStack>:
{
     7f4:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
     7f6:	1f03      	subs	r3, r0, #4
     7f8:	2480      	movs	r4, #128	; 0x80
     7fa:	0464      	lsls	r4, r4, #17
     7fc:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
     7fe:	3b04      	subs	r3, #4
     800:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
     802:	3b04      	subs	r3, #4
     804:	4902      	ldr	r1, [pc, #8]	; (810 <pxPortInitialiseStack+0x1c>)
     806:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
     808:	3b14      	subs	r3, #20
     80a:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8; /* R11..R4. */
     80c:	3840      	subs	r0, #64	; 0x40
}
     80e:	bd10      	pop	{r4, pc}
     810:	00000799 	.word	0x00000799

00000814 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
     814:	b510      	push	{r4, lr}
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
     816:	4b0f      	ldr	r3, [pc, #60]	; (854 <xPortStartScheduler+0x40>)
     818:	6819      	ldr	r1, [r3, #0]
     81a:	22ff      	movs	r2, #255	; 0xff
     81c:	0412      	lsls	r2, r2, #16
     81e:	430a      	orrs	r2, r1
     820:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
     822:	6819      	ldr	r1, [r3, #0]
     824:	22ff      	movs	r2, #255	; 0xff
     826:	0612      	lsls	r2, r2, #24
     828:	430a      	orrs	r2, r1
     82a:	601a      	str	r2, [r3, #0]
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Stop and reset the SysTick. */
	*(portNVIC_SYSTICK_CTRL) = 0UL;
     82c:	4a0a      	ldr	r2, [pc, #40]	; (858 <xPortStartScheduler+0x44>)
     82e:	2300      	movs	r3, #0
     830:	6013      	str	r3, [r2, #0]
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;
     832:	490a      	ldr	r1, [pc, #40]	; (85c <xPortStartScheduler+0x48>)
     834:	600b      	str	r3, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
     836:	480a      	ldr	r0, [pc, #40]	; (860 <xPortStartScheduler+0x4c>)
     838:	490a      	ldr	r1, [pc, #40]	; (864 <xPortStartScheduler+0x50>)
     83a:	6008      	str	r0, [r1, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
     83c:	2107      	movs	r1, #7
     83e:	6011      	str	r1, [r2, #0]
	uxCriticalNesting = 0;
     840:	4a09      	ldr	r2, [pc, #36]	; (868 <xPortStartScheduler+0x54>)
     842:	6013      	str	r3, [r2, #0]
	vPortStartFirstTask();
     844:	4b09      	ldr	r3, [pc, #36]	; (86c <xPortStartScheduler+0x58>)
     846:	4798      	blx	r3
	vTaskSwitchContext();
     848:	4b09      	ldr	r3, [pc, #36]	; (870 <xPortStartScheduler+0x5c>)
     84a:	4798      	blx	r3
	prvTaskExitError();
     84c:	4b09      	ldr	r3, [pc, #36]	; (874 <xPortStartScheduler+0x60>)
     84e:	4798      	blx	r3
}
     850:	2000      	movs	r0, #0
     852:	bd10      	pop	{r4, pc}
     854:	e000ed20 	.word	0xe000ed20
     858:	e000e010 	.word	0xe000e010
     85c:	e000e018 	.word	0xe000e018
     860:	000176ff 	.word	0x000176ff
     864:	e000e014 	.word	0xe000e014
     868:	20000008 	.word	0x20000008
     86c:	000007c1 	.word	0x000007c1
     870:	000015d5 	.word	0x000015d5
     874:	00000799 	.word	0x00000799

00000878 <vPortYield>:
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
     878:	2280      	movs	r2, #128	; 0x80
     87a:	0552      	lsls	r2, r2, #21
     87c:	4b03      	ldr	r3, [pc, #12]	; (88c <vPortYield+0x14>)
     87e:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" ::: "memory" );
     880:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
     884:	f3bf 8f6f 	isb	sy
}
     888:	4770      	bx	lr
     88a:	46c0      	nop			; (mov r8, r8)
     88c:	e000ed04 	.word	0xe000ed04

00000890 <vPortEnterCritical>:
    portDISABLE_INTERRUPTS();
     890:	b672      	cpsid	i
    uxCriticalNesting++;
     892:	4a04      	ldr	r2, [pc, #16]	; (8a4 <vPortEnterCritical+0x14>)
     894:	6813      	ldr	r3, [r2, #0]
     896:	3301      	adds	r3, #1
     898:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" ::: "memory" );
     89a:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
     89e:	f3bf 8f6f 	isb	sy
}
     8a2:	4770      	bx	lr
     8a4:	20000008 	.word	0x20000008

000008a8 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
     8a8:	4b06      	ldr	r3, [pc, #24]	; (8c4 <vPortExitCritical+0x1c>)
     8aa:	681b      	ldr	r3, [r3, #0]
     8ac:	2b00      	cmp	r3, #0
     8ae:	d101      	bne.n	8b4 <vPortExitCritical+0xc>
     8b0:	b672      	cpsid	i
     8b2:	e7fe      	b.n	8b2 <vPortExitCritical+0xa>
    uxCriticalNesting--;
     8b4:	3b01      	subs	r3, #1
     8b6:	4a03      	ldr	r2, [pc, #12]	; (8c4 <vPortExitCritical+0x1c>)
     8b8:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
     8ba:	2b00      	cmp	r3, #0
     8bc:	d100      	bne.n	8c0 <vPortExitCritical+0x18>
        portENABLE_INTERRUPTS();
     8be:	b662      	cpsie	i
}
     8c0:	4770      	bx	lr
     8c2:	46c0      	nop			; (mov r8, r8)
     8c4:	20000008 	.word	0x20000008

000008c8 <ulSetInterruptMaskFromISR>:
	__asm volatile(
     8c8:	f3ef 8010 	mrs	r0, PRIMASK
     8cc:	b672      	cpsid	i
     8ce:	4770      	bx	lr

000008d0 <vClearInterruptMaskFromISR>:
	__asm volatile(
     8d0:	f380 8810 	msr	PRIMASK, r0
     8d4:	4770      	bx	lr
	...

000008e0 <PendSV_Handler>:
	__asm volatile
     8e0:	f3ef 8009 	mrs	r0, PSP
     8e4:	4b0e      	ldr	r3, [pc, #56]	; (920 <pxCurrentTCBConst>)
     8e6:	681a      	ldr	r2, [r3, #0]
     8e8:	3820      	subs	r0, #32
     8ea:	6010      	str	r0, [r2, #0]
     8ec:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     8ee:	4644      	mov	r4, r8
     8f0:	464d      	mov	r5, r9
     8f2:	4656      	mov	r6, sl
     8f4:	465f      	mov	r7, fp
     8f6:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     8f8:	b508      	push	{r3, lr}
     8fa:	b672      	cpsid	i
     8fc:	f000 fe6a 	bl	15d4 <vTaskSwitchContext>
     900:	b662      	cpsie	i
     902:	bc0c      	pop	{r2, r3}
     904:	6811      	ldr	r1, [r2, #0]
     906:	6808      	ldr	r0, [r1, #0]
     908:	3010      	adds	r0, #16
     90a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     90c:	46a0      	mov	r8, r4
     90e:	46a9      	mov	r9, r5
     910:	46b2      	mov	sl, r6
     912:	46bb      	mov	fp, r7
     914:	f380 8809 	msr	PSP, r0
     918:	3820      	subs	r0, #32
     91a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     91c:	4718      	bx	r3
     91e:	46c0      	nop			; (mov r8, r8)

00000920 <pxCurrentTCBConst>:
     920:	200043cc 	.word	0x200043cc

00000924 <SysTick_Handler>:
{
     924:	b510      	push	{r4, lr}
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
     926:	4b07      	ldr	r3, [pc, #28]	; (944 <SysTick_Handler+0x20>)
     928:	4798      	blx	r3
     92a:	0004      	movs	r4, r0
		if( xTaskIncrementTick() != pdFALSE )
     92c:	4b06      	ldr	r3, [pc, #24]	; (948 <SysTick_Handler+0x24>)
     92e:	4798      	blx	r3
     930:	2800      	cmp	r0, #0
     932:	d003      	beq.n	93c <SysTick_Handler+0x18>
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
     934:	2280      	movs	r2, #128	; 0x80
     936:	0552      	lsls	r2, r2, #21
     938:	4b04      	ldr	r3, [pc, #16]	; (94c <SysTick_Handler+0x28>)
     93a:	601a      	str	r2, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
     93c:	0020      	movs	r0, r4
     93e:	4b04      	ldr	r3, [pc, #16]	; (950 <SysTick_Handler+0x2c>)
     940:	4798      	blx	r3
}
     942:	bd10      	pop	{r4, pc}
     944:	000008c9 	.word	0x000008c9
     948:	00001391 	.word	0x00001391
     94c:	e000ed04 	.word	0xe000ed04
     950:	000008d1 	.word	0x000008d1

00000954 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
     954:	b510      	push	{r4, lr}
     956:	0004      	movs	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
     958:	4b03      	ldr	r3, [pc, #12]	; (968 <prvIsQueueEmpty+0x14>)
     95a:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     95c:	6ba4      	ldr	r4, [r4, #56]	; 0x38
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     95e:	4b03      	ldr	r3, [pc, #12]	; (96c <prvIsQueueEmpty+0x18>)
     960:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     962:	4260      	negs	r0, r4
     964:	4160      	adcs	r0, r4

	return xReturn;
}
     966:	bd10      	pop	{r4, pc}
     968:	00000891 	.word	0x00000891
     96c:	000008a9 	.word	0x000008a9

00000970 <prvCopyDataToQueue>:
{
     970:	b570      	push	{r4, r5, r6, lr}
     972:	0004      	movs	r4, r0
     974:	0016      	movs	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     976:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     978:	6c02      	ldr	r2, [r0, #64]	; 0x40
     97a:	2a00      	cmp	r2, #0
     97c:	d10b      	bne.n	996 <prvCopyDataToQueue+0x26>
BaseType_t xReturn = pdFALSE;
     97e:	2000      	movs	r0, #0
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     980:	6823      	ldr	r3, [r4, #0]
     982:	4283      	cmp	r3, r0
     984:	d104      	bne.n	990 <prvCopyDataToQueue+0x20>
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     986:	6860      	ldr	r0, [r4, #4]
     988:	4b16      	ldr	r3, [pc, #88]	; (9e4 <prvCopyDataToQueue+0x74>)
     98a:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
     98c:	2300      	movs	r3, #0
     98e:	6063      	str	r3, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
     990:	3501      	adds	r5, #1
     992:	63a5      	str	r5, [r4, #56]	; 0x38
}
     994:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
     996:	2e00      	cmp	r6, #0
     998:	d10e      	bne.n	9b8 <prvCopyDataToQueue+0x48>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     99a:	6880      	ldr	r0, [r0, #8]
     99c:	4b12      	ldr	r3, [pc, #72]	; (9e8 <prvCopyDataToQueue+0x78>)
     99e:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     9a0:	68a3      	ldr	r3, [r4, #8]
     9a2:	6c22      	ldr	r2, [r4, #64]	; 0x40
     9a4:	4694      	mov	ip, r2
     9a6:	4463      	add	r3, ip
     9a8:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
     9aa:	2000      	movs	r0, #0
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     9ac:	6862      	ldr	r2, [r4, #4]
     9ae:	4293      	cmp	r3, r2
     9b0:	d3ee      	bcc.n	990 <prvCopyDataToQueue+0x20>
			pxQueue->pcWriteTo = pxQueue->pcHead;
     9b2:	6823      	ldr	r3, [r4, #0]
     9b4:	60a3      	str	r3, [r4, #8]
     9b6:	e7eb      	b.n	990 <prvCopyDataToQueue+0x20>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     9b8:	68c0      	ldr	r0, [r0, #12]
     9ba:	4b0b      	ldr	r3, [pc, #44]	; (9e8 <prvCopyDataToQueue+0x78>)
     9bc:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     9be:	6c23      	ldr	r3, [r4, #64]	; 0x40
     9c0:	425b      	negs	r3, r3
     9c2:	68e2      	ldr	r2, [r4, #12]
     9c4:	18d2      	adds	r2, r2, r3
     9c6:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     9c8:	6821      	ldr	r1, [r4, #0]
     9ca:	428a      	cmp	r2, r1
     9cc:	d203      	bcs.n	9d6 <prvCopyDataToQueue+0x66>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     9ce:	6862      	ldr	r2, [r4, #4]
     9d0:	4694      	mov	ip, r2
     9d2:	4463      	add	r3, ip
     9d4:	60e3      	str	r3, [r4, #12]
BaseType_t xReturn = pdFALSE;
     9d6:	2000      	movs	r0, #0
		if( xPosition == queueOVERWRITE )
     9d8:	2e02      	cmp	r6, #2
     9da:	d1d9      	bne.n	990 <prvCopyDataToQueue+0x20>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     9dc:	4285      	cmp	r5, r0
     9de:	d0d7      	beq.n	990 <prvCopyDataToQueue+0x20>
				--uxMessagesWaiting;
     9e0:	3d01      	subs	r5, #1
     9e2:	e7d5      	b.n	990 <prvCopyDataToQueue+0x20>
     9e4:	000017f1 	.word	0x000017f1
     9e8:	00001cd9 	.word	0x00001cd9

000009ec <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
     9ec:	b570      	push	{r4, r5, r6, lr}
     9ee:	b082      	sub	sp, #8
     9f0:	9001      	str	r0, [sp, #4]
     9f2:	000a      	movs	r2, r1
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
     9f4:	6c84      	ldr	r4, [r0, #72]	; 0x48
	BaseType_t xReturn = pdFALSE;

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
     9f6:	2c00      	cmp	r4, #0
     9f8:	d005      	beq.n	a06 <prvNotifyQueueSetContainer+0x1a>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
     9fa:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     9fc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     9fe:	4299      	cmp	r1, r3
     a00:	d303      	bcc.n	a0a <prvNotifyQueueSetContainer+0x1e>
     a02:	b672      	cpsid	i
     a04:	e7fe      	b.n	a04 <prvNotifyQueueSetContainer+0x18>
		configASSERT( pxQueueSetContainer );
     a06:	b672      	cpsid	i
     a08:	e7fe      	b.n	a08 <prvNotifyQueueSetContainer+0x1c>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
     a0a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
	BaseType_t xReturn = pdFALSE;
     a0c:	2600      	movs	r6, #0
		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
     a0e:	428b      	cmp	r3, r1
     a10:	d802      	bhi.n	a18 <prvNotifyQueueSetContainer+0x2c>
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
     a12:	0030      	movs	r0, r6
     a14:	b002      	add	sp, #8
     a16:	bd70      	pop	{r4, r5, r6, pc}
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
     a18:	2345      	movs	r3, #69	; 0x45
     a1a:	5ce5      	ldrb	r5, [r4, r3]
     a1c:	b26d      	sxtb	r5, r5
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
     a1e:	a901      	add	r1, sp, #4
     a20:	0020      	movs	r0, r4
     a22:	4b0a      	ldr	r3, [pc, #40]	; (a4c <prvNotifyQueueSetContainer+0x60>)
     a24:	4798      	blx	r3
     a26:	0006      	movs	r6, r0
			if( cTxLock == queueUNLOCKED )
     a28:	1c6b      	adds	r3, r5, #1
     a2a:	d10a      	bne.n	a42 <prvNotifyQueueSetContainer+0x56>
				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
     a2c:	6a63      	ldr	r3, [r4, #36]	; 0x24
     a2e:	2b00      	cmp	r3, #0
     a30:	d0ef      	beq.n	a12 <prvNotifyQueueSetContainer+0x26>
					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
     a32:	0020      	movs	r0, r4
     a34:	3024      	adds	r0, #36	; 0x24
     a36:	4b06      	ldr	r3, [pc, #24]	; (a50 <prvNotifyQueueSetContainer+0x64>)
     a38:	4798      	blx	r3
     a3a:	2800      	cmp	r0, #0
     a3c:	d0e9      	beq.n	a12 <prvNotifyQueueSetContainer+0x26>
						xReturn = pdTRUE;
     a3e:	2601      	movs	r6, #1
     a40:	e7e7      	b.n	a12 <prvNotifyQueueSetContainer+0x26>
				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
     a42:	3501      	adds	r5, #1
     a44:	b26d      	sxtb	r5, r5
     a46:	2345      	movs	r3, #69	; 0x45
     a48:	54e5      	strb	r5, [r4, r3]
     a4a:	e7e2      	b.n	a12 <prvNotifyQueueSetContainer+0x26>
     a4c:	00000971 	.word	0x00000971
     a50:	000016cd 	.word	0x000016cd

00000a54 <prvCopyDataFromQueue>:
{
     a54:	b510      	push	{r4, lr}
     a56:	000c      	movs	r4, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     a58:	6c02      	ldr	r2, [r0, #64]	; 0x40
     a5a:	2a00      	cmp	r2, #0
     a5c:	d00b      	beq.n	a76 <prvCopyDataFromQueue+0x22>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     a5e:	68c3      	ldr	r3, [r0, #12]
     a60:	189b      	adds	r3, r3, r2
     a62:	60c3      	str	r3, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     a64:	6841      	ldr	r1, [r0, #4]
     a66:	428b      	cmp	r3, r1
     a68:	d301      	bcc.n	a6e <prvCopyDataFromQueue+0x1a>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     a6a:	6803      	ldr	r3, [r0, #0]
     a6c:	60c3      	str	r3, [r0, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     a6e:	68c1      	ldr	r1, [r0, #12]
     a70:	0020      	movs	r0, r4
     a72:	4b01      	ldr	r3, [pc, #4]	; (a78 <prvCopyDataFromQueue+0x24>)
     a74:	4798      	blx	r3
}
     a76:	bd10      	pop	{r4, pc}
     a78:	00001cd9 	.word	0x00001cd9

00000a7c <prvUnlockQueue>:
{
     a7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     a7e:	0007      	movs	r7, r0
	taskENTER_CRITICAL();
     a80:	4b25      	ldr	r3, [pc, #148]	; (b18 <prvUnlockQueue+0x9c>)
     a82:	4798      	blx	r3
		int8_t cTxLock = pxQueue->cTxLock;
     a84:	2345      	movs	r3, #69	; 0x45
     a86:	5cfc      	ldrb	r4, [r7, r3]
     a88:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
     a8a:	2c00      	cmp	r4, #0
     a8c:	dd1c      	ble.n	ac8 <prvUnlockQueue+0x4c>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
     a8e:	4e23      	ldr	r6, [pc, #140]	; (b1c <prvUnlockQueue+0xa0>)
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     a90:	4d23      	ldr	r5, [pc, #140]	; (b20 <prvUnlockQueue+0xa4>)
     a92:	e00b      	b.n	aac <prvUnlockQueue+0x30>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     a94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     a96:	2b00      	cmp	r3, #0
     a98:	d016      	beq.n	ac8 <prvUnlockQueue+0x4c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     a9a:	0038      	movs	r0, r7
     a9c:	3024      	adds	r0, #36	; 0x24
     a9e:	47a8      	blx	r5
     aa0:	2800      	cmp	r0, #0
     aa2:	d10e      	bne.n	ac2 <prvUnlockQueue+0x46>
     aa4:	3c01      	subs	r4, #1
     aa6:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
     aa8:	2c00      	cmp	r4, #0
     aaa:	d00d      	beq.n	ac8 <prvUnlockQueue+0x4c>
				if( pxQueue->pxQueueSetContainer != NULL )
     aac:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     aae:	2b00      	cmp	r3, #0
     ab0:	d0f0      	beq.n	a94 <prvUnlockQueue+0x18>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
     ab2:	2100      	movs	r1, #0
     ab4:	0038      	movs	r0, r7
     ab6:	47b0      	blx	r6
     ab8:	2800      	cmp	r0, #0
     aba:	d0f3      	beq.n	aa4 <prvUnlockQueue+0x28>
						vTaskMissedYield();
     abc:	4b19      	ldr	r3, [pc, #100]	; (b24 <prvUnlockQueue+0xa8>)
     abe:	4798      	blx	r3
     ac0:	e7f0      	b.n	aa4 <prvUnlockQueue+0x28>
							vTaskMissedYield();
     ac2:	4b18      	ldr	r3, [pc, #96]	; (b24 <prvUnlockQueue+0xa8>)
     ac4:	4798      	blx	r3
     ac6:	e7ed      	b.n	aa4 <prvUnlockQueue+0x28>
		pxQueue->cTxLock = queueUNLOCKED;
     ac8:	22ff      	movs	r2, #255	; 0xff
     aca:	2345      	movs	r3, #69	; 0x45
     acc:	54fa      	strb	r2, [r7, r3]
	taskEXIT_CRITICAL();
     ace:	4b16      	ldr	r3, [pc, #88]	; (b28 <prvUnlockQueue+0xac>)
     ad0:	4798      	blx	r3
	taskENTER_CRITICAL();
     ad2:	4b11      	ldr	r3, [pc, #68]	; (b18 <prvUnlockQueue+0x9c>)
     ad4:	4798      	blx	r3
		int8_t cRxLock = pxQueue->cRxLock;
     ad6:	2344      	movs	r3, #68	; 0x44
     ad8:	5cfc      	ldrb	r4, [r7, r3]
     ada:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
     adc:	2c00      	cmp	r4, #0
     ade:	dd14      	ble.n	b0a <prvUnlockQueue+0x8e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ae0:	693b      	ldr	r3, [r7, #16]
     ae2:	2b00      	cmp	r3, #0
     ae4:	d011      	beq.n	b0a <prvUnlockQueue+0x8e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ae6:	003d      	movs	r5, r7
     ae8:	3510      	adds	r5, #16
     aea:	4e0d      	ldr	r6, [pc, #52]	; (b20 <prvUnlockQueue+0xa4>)
     aec:	e006      	b.n	afc <prvUnlockQueue+0x80>
     aee:	3c01      	subs	r4, #1
     af0:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
     af2:	2c00      	cmp	r4, #0
     af4:	d009      	beq.n	b0a <prvUnlockQueue+0x8e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     af6:	693b      	ldr	r3, [r7, #16]
     af8:	2b00      	cmp	r3, #0
     afa:	d006      	beq.n	b0a <prvUnlockQueue+0x8e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     afc:	0028      	movs	r0, r5
     afe:	47b0      	blx	r6
     b00:	2800      	cmp	r0, #0
     b02:	d0f4      	beq.n	aee <prvUnlockQueue+0x72>
					vTaskMissedYield();
     b04:	4b07      	ldr	r3, [pc, #28]	; (b24 <prvUnlockQueue+0xa8>)
     b06:	4798      	blx	r3
     b08:	e7f1      	b.n	aee <prvUnlockQueue+0x72>
		pxQueue->cRxLock = queueUNLOCKED;
     b0a:	22ff      	movs	r2, #255	; 0xff
     b0c:	2344      	movs	r3, #68	; 0x44
     b0e:	54fa      	strb	r2, [r7, r3]
	taskEXIT_CRITICAL();
     b10:	4b05      	ldr	r3, [pc, #20]	; (b28 <prvUnlockQueue+0xac>)
     b12:	4798      	blx	r3
}
     b14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     b16:	46c0      	nop			; (mov r8, r8)
     b18:	00000891 	.word	0x00000891
     b1c:	000009ed 	.word	0x000009ed
     b20:	000016cd 	.word	0x000016cd
     b24:	000017c9 	.word	0x000017c9
     b28:	000008a9 	.word	0x000008a9

00000b2c <xQueueGenericReset>:
{
     b2c:	b570      	push	{r4, r5, r6, lr}
     b2e:	0004      	movs	r4, r0
     b30:	000d      	movs	r5, r1
	configASSERT( pxQueue );
     b32:	2800      	cmp	r0, #0
     b34:	d021      	beq.n	b7a <xQueueGenericReset+0x4e>
	taskENTER_CRITICAL();
     b36:	4b17      	ldr	r3, [pc, #92]	; (b94 <xQueueGenericReset+0x68>)
     b38:	4798      	blx	r3
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     b3a:	6822      	ldr	r2, [r4, #0]
     b3c:	6c21      	ldr	r1, [r4, #64]	; 0x40
     b3e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     b40:	434b      	muls	r3, r1
     b42:	18d0      	adds	r0, r2, r3
     b44:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     b46:	2000      	movs	r0, #0
     b48:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
     b4a:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     b4c:	1a5b      	subs	r3, r3, r1
     b4e:	18d3      	adds	r3, r2, r3
     b50:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
     b52:	23ff      	movs	r3, #255	; 0xff
     b54:	2244      	movs	r2, #68	; 0x44
     b56:	54a3      	strb	r3, [r4, r2]
		pxQueue->cTxLock = queueUNLOCKED;
     b58:	3201      	adds	r2, #1
     b5a:	54a3      	strb	r3, [r4, r2]
		if( xNewQueue == pdFALSE )
     b5c:	2d00      	cmp	r5, #0
     b5e:	d111      	bne.n	b84 <xQueueGenericReset+0x58>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     b60:	6923      	ldr	r3, [r4, #16]
     b62:	2b00      	cmp	r3, #0
     b64:	d005      	beq.n	b72 <xQueueGenericReset+0x46>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     b66:	0020      	movs	r0, r4
     b68:	3010      	adds	r0, #16
     b6a:	4b0b      	ldr	r3, [pc, #44]	; (b98 <xQueueGenericReset+0x6c>)
     b6c:	4798      	blx	r3
     b6e:	2800      	cmp	r0, #0
     b70:	d105      	bne.n	b7e <xQueueGenericReset+0x52>
	taskEXIT_CRITICAL();
     b72:	4b0a      	ldr	r3, [pc, #40]	; (b9c <xQueueGenericReset+0x70>)
     b74:	4798      	blx	r3
}
     b76:	2001      	movs	r0, #1
     b78:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxQueue );
     b7a:	b672      	cpsid	i
     b7c:	e7fe      	b.n	b7c <xQueueGenericReset+0x50>
					queueYIELD_IF_USING_PREEMPTION();
     b7e:	4b08      	ldr	r3, [pc, #32]	; (ba0 <xQueueGenericReset+0x74>)
     b80:	4798      	blx	r3
     b82:	e7f6      	b.n	b72 <xQueueGenericReset+0x46>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     b84:	0020      	movs	r0, r4
     b86:	3010      	adds	r0, #16
     b88:	4d06      	ldr	r5, [pc, #24]	; (ba4 <xQueueGenericReset+0x78>)
     b8a:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     b8c:	0020      	movs	r0, r4
     b8e:	3024      	adds	r0, #36	; 0x24
     b90:	47a8      	blx	r5
     b92:	e7ee      	b.n	b72 <xQueueGenericReset+0x46>
     b94:	00000891 	.word	0x00000891
     b98:	000016cd 	.word	0x000016cd
     b9c:	000008a9 	.word	0x000008a9
     ba0:	00000879 	.word	0x00000879
     ba4:	00000321 	.word	0x00000321

00000ba8 <xQueueGenericCreate>:
	{
     ba8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     baa:	0006      	movs	r6, r0
     bac:	000d      	movs	r5, r1
     bae:	0017      	movs	r7, r2
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
     bb0:	2800      	cmp	r0, #0
     bb2:	d101      	bne.n	bb8 <xQueueGenericCreate+0x10>
     bb4:	b672      	cpsid	i
     bb6:	e7fe      	b.n	bb6 <xQueueGenericCreate+0xe>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     bb8:	0008      	movs	r0, r1
     bba:	4370      	muls	r0, r6
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     bbc:	3054      	adds	r0, #84	; 0x54
     bbe:	4b0b      	ldr	r3, [pc, #44]	; (bec <xQueueGenericCreate+0x44>)
     bc0:	4798      	blx	r3
     bc2:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
     bc4:	d010      	beq.n	be8 <xQueueGenericCreate+0x40>
	if( uxItemSize == ( UBaseType_t ) 0 )
     bc6:	2d00      	cmp	r5, #0
     bc8:	d003      	beq.n	bd2 <xQueueGenericCreate+0x2a>
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
     bca:	0003      	movs	r3, r0
     bcc:	3354      	adds	r3, #84	; 0x54
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     bce:	6003      	str	r3, [r0, #0]
     bd0:	e000      	b.n	bd4 <xQueueGenericCreate+0x2c>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     bd2:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
     bd4:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
     bd6:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     bd8:	2101      	movs	r1, #1
     bda:	0020      	movs	r0, r4
     bdc:	4b04      	ldr	r3, [pc, #16]	; (bf0 <xQueueGenericCreate+0x48>)
     bde:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
     be0:	2350      	movs	r3, #80	; 0x50
     be2:	54e7      	strb	r7, [r4, r3]
		pxNewQueue->pxQueueSetContainer = NULL;
     be4:	2300      	movs	r3, #0
     be6:	64a3      	str	r3, [r4, #72]	; 0x48
	}
     be8:	0020      	movs	r0, r4
     bea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     bec:	0000020d 	.word	0x0000020d
     bf0:	00000b2d 	.word	0x00000b2d

00000bf4 <xQueueGenericSend>:
{
     bf4:	b5f0      	push	{r4, r5, r6, r7, lr}
     bf6:	46ce      	mov	lr, r9
     bf8:	4647      	mov	r7, r8
     bfa:	b580      	push	{r7, lr}
     bfc:	b085      	sub	sp, #20
     bfe:	0004      	movs	r4, r0
     c00:	000f      	movs	r7, r1
     c02:	9201      	str	r2, [sp, #4]
     c04:	001d      	movs	r5, r3
	configASSERT( pxQueue );
     c06:	2800      	cmp	r0, #0
     c08:	d00c      	beq.n	c24 <xQueueGenericSend+0x30>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     c0a:	2900      	cmp	r1, #0
     c0c:	d00c      	beq.n	c28 <xQueueGenericSend+0x34>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     c0e:	2d02      	cmp	r5, #2
     c10:	d00f      	beq.n	c32 <xQueueGenericSend+0x3e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
     c12:	4b4e      	ldr	r3, [pc, #312]	; (d4c <xQueueGenericSend+0x158>)
     c14:	4798      	blx	r3
     c16:	2800      	cmp	r0, #0
     c18:	d110      	bne.n	c3c <xQueueGenericSend+0x48>
     c1a:	9b01      	ldr	r3, [sp, #4]
     c1c:	2b00      	cmp	r3, #0
     c1e:	d011      	beq.n	c44 <xQueueGenericSend+0x50>
     c20:	b672      	cpsid	i
     c22:	e7fe      	b.n	c22 <xQueueGenericSend+0x2e>
	configASSERT( pxQueue );
     c24:	b672      	cpsid	i
     c26:	e7fe      	b.n	c26 <xQueueGenericSend+0x32>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     c28:	6c03      	ldr	r3, [r0, #64]	; 0x40
     c2a:	2b00      	cmp	r3, #0
     c2c:	d0ef      	beq.n	c0e <xQueueGenericSend+0x1a>
     c2e:	b672      	cpsid	i
     c30:	e7fe      	b.n	c30 <xQueueGenericSend+0x3c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     c32:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     c34:	2b01      	cmp	r3, #1
     c36:	d0ec      	beq.n	c12 <xQueueGenericSend+0x1e>
     c38:	b672      	cpsid	i
     c3a:	e7fe      	b.n	c3a <xQueueGenericSend+0x46>
     c3c:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
     c3e:	4b44      	ldr	r3, [pc, #272]	; (d50 <xQueueGenericSend+0x15c>)
     c40:	4698      	mov	r8, r3
     c42:	e04c      	b.n	cde <xQueueGenericSend+0xea>
     c44:	2600      	movs	r6, #0
     c46:	e7fa      	b.n	c3e <xQueueGenericSend+0x4a>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     c48:	002a      	movs	r2, r5
     c4a:	0039      	movs	r1, r7
     c4c:	0020      	movs	r0, r4
     c4e:	4b41      	ldr	r3, [pc, #260]	; (d54 <xQueueGenericSend+0x160>)
     c50:	4798      	blx	r3
					if( pxQueue->pxQueueSetContainer != NULL )
     c52:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     c54:	2b00      	cmp	r3, #0
     c56:	d00f      	beq.n	c78 <xQueueGenericSend+0x84>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
     c58:	0029      	movs	r1, r5
     c5a:	0020      	movs	r0, r4
     c5c:	4b3e      	ldr	r3, [pc, #248]	; (d58 <xQueueGenericSend+0x164>)
     c5e:	4798      	blx	r3
     c60:	2800      	cmp	r0, #0
     c62:	d001      	beq.n	c68 <xQueueGenericSend+0x74>
							queueYIELD_IF_USING_PREEMPTION();
     c64:	4b3d      	ldr	r3, [pc, #244]	; (d5c <xQueueGenericSend+0x168>)
     c66:	4798      	blx	r3
				taskEXIT_CRITICAL();
     c68:	4b3d      	ldr	r3, [pc, #244]	; (d60 <xQueueGenericSend+0x16c>)
     c6a:	4798      	blx	r3
				return pdPASS;
     c6c:	2001      	movs	r0, #1
}
     c6e:	b005      	add	sp, #20
     c70:	bc0c      	pop	{r2, r3}
     c72:	4690      	mov	r8, r2
     c74:	4699      	mov	r9, r3
     c76:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c78:	6a63      	ldr	r3, [r4, #36]	; 0x24
     c7a:	2b00      	cmp	r3, #0
     c7c:	d008      	beq.n	c90 <xQueueGenericSend+0x9c>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c7e:	0020      	movs	r0, r4
     c80:	3024      	adds	r0, #36	; 0x24
     c82:	4b38      	ldr	r3, [pc, #224]	; (d64 <xQueueGenericSend+0x170>)
     c84:	4798      	blx	r3
     c86:	2800      	cmp	r0, #0
     c88:	d0ee      	beq.n	c68 <xQueueGenericSend+0x74>
								queueYIELD_IF_USING_PREEMPTION();
     c8a:	4b34      	ldr	r3, [pc, #208]	; (d5c <xQueueGenericSend+0x168>)
     c8c:	4798      	blx	r3
     c8e:	e7eb      	b.n	c68 <xQueueGenericSend+0x74>
						else if( xYieldRequired != pdFALSE )
     c90:	2800      	cmp	r0, #0
     c92:	d0e9      	beq.n	c68 <xQueueGenericSend+0x74>
							queueYIELD_IF_USING_PREEMPTION();
     c94:	4b31      	ldr	r3, [pc, #196]	; (d5c <xQueueGenericSend+0x168>)
     c96:	4798      	blx	r3
     c98:	e7e6      	b.n	c68 <xQueueGenericSend+0x74>
					taskEXIT_CRITICAL();
     c9a:	4b31      	ldr	r3, [pc, #196]	; (d60 <xQueueGenericSend+0x16c>)
     c9c:	4798      	blx	r3
					return errQUEUE_FULL;
     c9e:	2000      	movs	r0, #0
     ca0:	e7e5      	b.n	c6e <xQueueGenericSend+0x7a>
		prvLockQueue( pxQueue );
     ca2:	4b2f      	ldr	r3, [pc, #188]	; (d60 <xQueueGenericSend+0x16c>)
     ca4:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ca6:	a901      	add	r1, sp, #4
     ca8:	a802      	add	r0, sp, #8
     caa:	4b2f      	ldr	r3, [pc, #188]	; (d68 <xQueueGenericSend+0x174>)
     cac:	4798      	blx	r3
     cae:	2800      	cmp	r0, #0
     cb0:	d144      	bne.n	d3c <xQueueGenericSend+0x148>
	taskENTER_CRITICAL();
     cb2:	4b27      	ldr	r3, [pc, #156]	; (d50 <xQueueGenericSend+0x15c>)
     cb4:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     cb6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     cb8:	4699      	mov	r9, r3
     cba:	6be6      	ldr	r6, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
     cbc:	4b28      	ldr	r3, [pc, #160]	; (d60 <xQueueGenericSend+0x16c>)
     cbe:	4798      	blx	r3
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     cc0:	45b1      	cmp	r9, r6
     cc2:	d135      	bne.n	d30 <xQueueGenericSend+0x13c>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     cc4:	0020      	movs	r0, r4
     cc6:	3010      	adds	r0, #16
     cc8:	9901      	ldr	r1, [sp, #4]
     cca:	4b28      	ldr	r3, [pc, #160]	; (d6c <xQueueGenericSend+0x178>)
     ccc:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
     cce:	0020      	movs	r0, r4
     cd0:	4b27      	ldr	r3, [pc, #156]	; (d70 <xQueueGenericSend+0x17c>)
     cd2:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
     cd4:	4b27      	ldr	r3, [pc, #156]	; (d74 <xQueueGenericSend+0x180>)
     cd6:	4798      	blx	r3
     cd8:	2800      	cmp	r0, #0
     cda:	d026      	beq.n	d2a <xQueueGenericSend+0x136>
     cdc:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
     cde:	47c0      	blx	r8
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     ce0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     ce2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
     ce4:	4293      	cmp	r3, r2
     ce6:	d3af      	bcc.n	c48 <xQueueGenericSend+0x54>
     ce8:	2d02      	cmp	r5, #2
     cea:	d0ad      	beq.n	c48 <xQueueGenericSend+0x54>
				if( xTicksToWait == ( TickType_t ) 0 )
     cec:	9b01      	ldr	r3, [sp, #4]
     cee:	2b00      	cmp	r3, #0
     cf0:	d0d3      	beq.n	c9a <xQueueGenericSend+0xa6>
				else if( xEntryTimeSet == pdFALSE )
     cf2:	2e00      	cmp	r6, #0
     cf4:	d102      	bne.n	cfc <xQueueGenericSend+0x108>
					vTaskInternalSetTimeOutState( &xTimeOut );
     cf6:	a802      	add	r0, sp, #8
     cf8:	4b1f      	ldr	r3, [pc, #124]	; (d78 <xQueueGenericSend+0x184>)
     cfa:	4798      	blx	r3
		taskEXIT_CRITICAL();
     cfc:	4b18      	ldr	r3, [pc, #96]	; (d60 <xQueueGenericSend+0x16c>)
     cfe:	4798      	blx	r3
		vTaskSuspendAll();
     d00:	4b1e      	ldr	r3, [pc, #120]	; (d7c <xQueueGenericSend+0x188>)
     d02:	4798      	blx	r3
		prvLockQueue( pxQueue );
     d04:	4b12      	ldr	r3, [pc, #72]	; (d50 <xQueueGenericSend+0x15c>)
     d06:	4798      	blx	r3
     d08:	2344      	movs	r3, #68	; 0x44
     d0a:	5ce3      	ldrb	r3, [r4, r3]
     d0c:	b25b      	sxtb	r3, r3
     d0e:	3301      	adds	r3, #1
     d10:	d102      	bne.n	d18 <xQueueGenericSend+0x124>
     d12:	2200      	movs	r2, #0
     d14:	2344      	movs	r3, #68	; 0x44
     d16:	54e2      	strb	r2, [r4, r3]
     d18:	2345      	movs	r3, #69	; 0x45
     d1a:	5ce3      	ldrb	r3, [r4, r3]
     d1c:	b25b      	sxtb	r3, r3
     d1e:	3301      	adds	r3, #1
     d20:	d1bf      	bne.n	ca2 <xQueueGenericSend+0xae>
     d22:	2200      	movs	r2, #0
     d24:	2345      	movs	r3, #69	; 0x45
     d26:	54e2      	strb	r2, [r4, r3]
     d28:	e7bb      	b.n	ca2 <xQueueGenericSend+0xae>
					portYIELD_WITHIN_API();
     d2a:	4b0c      	ldr	r3, [pc, #48]	; (d5c <xQueueGenericSend+0x168>)
     d2c:	4798      	blx	r3
     d2e:	e7d5      	b.n	cdc <xQueueGenericSend+0xe8>
				prvUnlockQueue( pxQueue );
     d30:	0020      	movs	r0, r4
     d32:	4b0f      	ldr	r3, [pc, #60]	; (d70 <xQueueGenericSend+0x17c>)
     d34:	4798      	blx	r3
				( void ) xTaskResumeAll();
     d36:	4b0f      	ldr	r3, [pc, #60]	; (d74 <xQueueGenericSend+0x180>)
     d38:	4798      	blx	r3
     d3a:	e7cf      	b.n	cdc <xQueueGenericSend+0xe8>
			prvUnlockQueue( pxQueue );
     d3c:	0020      	movs	r0, r4
     d3e:	4b0c      	ldr	r3, [pc, #48]	; (d70 <xQueueGenericSend+0x17c>)
     d40:	4798      	blx	r3
			( void ) xTaskResumeAll();
     d42:	4b0c      	ldr	r3, [pc, #48]	; (d74 <xQueueGenericSend+0x180>)
     d44:	4798      	blx	r3
			return errQUEUE_FULL;
     d46:	2000      	movs	r0, #0
     d48:	e791      	b.n	c6e <xQueueGenericSend+0x7a>
     d4a:	46c0      	nop			; (mov r8, r8)
     d4c:	000017d5 	.word	0x000017d5
     d50:	00000891 	.word	0x00000891
     d54:	00000971 	.word	0x00000971
     d58:	000009ed 	.word	0x000009ed
     d5c:	00000879 	.word	0x00000879
     d60:	000008a9 	.word	0x000008a9
     d64:	000016cd 	.word	0x000016cd
     d68:	0000175d 	.word	0x0000175d
     d6c:	00001669 	.word	0x00001669
     d70:	00000a7d 	.word	0x00000a7d
     d74:	000014a1 	.word	0x000014a1
     d78:	0000174d 	.word	0x0000174d
     d7c:	00001375 	.word	0x00001375

00000d80 <xQueueGenericSendFromISR>:
{
     d80:	b5f0      	push	{r4, r5, r6, r7, lr}
     d82:	b083      	sub	sp, #12
     d84:	0004      	movs	r4, r0
     d86:	9101      	str	r1, [sp, #4]
     d88:	0016      	movs	r6, r2
     d8a:	001d      	movs	r5, r3
	configASSERT( pxQueue );
     d8c:	2800      	cmp	r0, #0
     d8e:	d012      	beq.n	db6 <xQueueGenericSendFromISR+0x36>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     d90:	9b01      	ldr	r3, [sp, #4]
     d92:	2b00      	cmp	r3, #0
     d94:	d011      	beq.n	dba <xQueueGenericSendFromISR+0x3a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     d96:	2d02      	cmp	r5, #2
     d98:	d014      	beq.n	dc4 <xQueueGenericSendFromISR+0x44>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     d9a:	4b28      	ldr	r3, [pc, #160]	; (e3c <xQueueGenericSendFromISR+0xbc>)
     d9c:	4798      	blx	r3
     d9e:	9000      	str	r0, [sp, #0]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     da0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     da2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
     da4:	429a      	cmp	r2, r3
     da6:	d82f      	bhi.n	e08 <xQueueGenericSendFromISR+0x88>
			xReturn = errQUEUE_FULL;
     da8:	2500      	movs	r5, #0
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
     daa:	9800      	ldr	r0, [sp, #0]
     dac:	4b24      	ldr	r3, [pc, #144]	; (e40 <xQueueGenericSendFromISR+0xc0>)
     dae:	4798      	blx	r3
}
     db0:	0028      	movs	r0, r5
     db2:	b003      	add	sp, #12
     db4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	configASSERT( pxQueue );
     db6:	b672      	cpsid	i
     db8:	e7fe      	b.n	db8 <xQueueGenericSendFromISR+0x38>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     dba:	6c03      	ldr	r3, [r0, #64]	; 0x40
     dbc:	2b00      	cmp	r3, #0
     dbe:	d0ea      	beq.n	d96 <xQueueGenericSendFromISR+0x16>
     dc0:	b672      	cpsid	i
     dc2:	e7fe      	b.n	dc2 <xQueueGenericSendFromISR+0x42>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     dc4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     dc6:	2b01      	cmp	r3, #1
     dc8:	d01a      	beq.n	e00 <xQueueGenericSendFromISR+0x80>
     dca:	b672      	cpsid	i
     dcc:	e7fe      	b.n	dcc <xQueueGenericSendFromISR+0x4c>
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     dce:	6a63      	ldr	r3, [r4, #36]	; 0x24
			xReturn = pdPASS;
     dd0:	2501      	movs	r5, #1
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     dd2:	2b00      	cmp	r3, #0
     dd4:	d0e9      	beq.n	daa <xQueueGenericSendFromISR+0x2a>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     dd6:	0020      	movs	r0, r4
     dd8:	3024      	adds	r0, #36	; 0x24
     dda:	4b1a      	ldr	r3, [pc, #104]	; (e44 <xQueueGenericSendFromISR+0xc4>)
     ddc:	4798      	blx	r3
     dde:	2800      	cmp	r0, #0
     de0:	d0e3      	beq.n	daa <xQueueGenericSendFromISR+0x2a>
								if( pxHigherPriorityTaskWoken != NULL )
     de2:	2e00      	cmp	r6, #0
     de4:	d00a      	beq.n	dfc <xQueueGenericSendFromISR+0x7c>
									*pxHigherPriorityTaskWoken = pdTRUE;
     de6:	2301      	movs	r3, #1
     de8:	6033      	str	r3, [r6, #0]
     dea:	e7de      	b.n	daa <xQueueGenericSendFromISR+0x2a>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     dec:	1c7b      	adds	r3, r7, #1
     dee:	b25b      	sxtb	r3, r3
     df0:	2245      	movs	r2, #69	; 0x45
     df2:	54a3      	strb	r3, [r4, r2]
			xReturn = pdPASS;
     df4:	2501      	movs	r5, #1
     df6:	e7d8      	b.n	daa <xQueueGenericSendFromISR+0x2a>
     df8:	2501      	movs	r5, #1
     dfa:	e7d6      	b.n	daa <xQueueGenericSendFromISR+0x2a>
     dfc:	2501      	movs	r5, #1
     dfe:	e7d4      	b.n	daa <xQueueGenericSendFromISR+0x2a>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     e00:	4b0e      	ldr	r3, [pc, #56]	; (e3c <xQueueGenericSendFromISR+0xbc>)
     e02:	4798      	blx	r3
     e04:	9000      	str	r0, [sp, #0]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     e06:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			const int8_t cTxLock = pxQueue->cTxLock;
     e08:	2345      	movs	r3, #69	; 0x45
     e0a:	5ce7      	ldrb	r7, [r4, r3]
     e0c:	b27f      	sxtb	r7, r7
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     e0e:	002a      	movs	r2, r5
     e10:	9901      	ldr	r1, [sp, #4]
     e12:	0020      	movs	r0, r4
     e14:	4b0c      	ldr	r3, [pc, #48]	; (e48 <xQueueGenericSendFromISR+0xc8>)
     e16:	4798      	blx	r3
			if( cTxLock == queueUNLOCKED )
     e18:	1c7b      	adds	r3, r7, #1
     e1a:	d1e7      	bne.n	dec <xQueueGenericSendFromISR+0x6c>
					if( pxQueue->pxQueueSetContainer != NULL )
     e1c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     e1e:	2b00      	cmp	r3, #0
     e20:	d0d5      	beq.n	dce <xQueueGenericSendFromISR+0x4e>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
     e22:	0029      	movs	r1, r5
     e24:	0020      	movs	r0, r4
     e26:	4b09      	ldr	r3, [pc, #36]	; (e4c <xQueueGenericSendFromISR+0xcc>)
     e28:	4798      	blx	r3
			xReturn = pdPASS;
     e2a:	2501      	movs	r5, #1
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
     e2c:	2800      	cmp	r0, #0
     e2e:	d0bc      	beq.n	daa <xQueueGenericSendFromISR+0x2a>
							if( pxHigherPriorityTaskWoken != NULL )
     e30:	2e00      	cmp	r6, #0
     e32:	d0e1      	beq.n	df8 <xQueueGenericSendFromISR+0x78>
								*pxHigherPriorityTaskWoken = pdTRUE;
     e34:	2301      	movs	r3, #1
     e36:	6033      	str	r3, [r6, #0]
     e38:	e7b7      	b.n	daa <xQueueGenericSendFromISR+0x2a>
     e3a:	46c0      	nop			; (mov r8, r8)
     e3c:	000008c9 	.word	0x000008c9
     e40:	000008d1 	.word	0x000008d1
     e44:	000016cd 	.word	0x000016cd
     e48:	00000971 	.word	0x00000971
     e4c:	000009ed 	.word	0x000009ed

00000e50 <xQueueReceive>:
{
     e50:	b5f0      	push	{r4, r5, r6, r7, lr}
     e52:	46c6      	mov	lr, r8
     e54:	b500      	push	{lr}
     e56:	b084      	sub	sp, #16
     e58:	0004      	movs	r4, r0
     e5a:	000f      	movs	r7, r1
     e5c:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
     e5e:	2800      	cmp	r0, #0
     e60:	d00a      	beq.n	e78 <xQueueReceive+0x28>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
     e62:	2900      	cmp	r1, #0
     e64:	d00a      	beq.n	e7c <xQueueReceive+0x2c>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
     e66:	4b42      	ldr	r3, [pc, #264]	; (f70 <xQueueReceive+0x120>)
     e68:	4798      	blx	r3
     e6a:	2800      	cmp	r0, #0
     e6c:	d10b      	bne.n	e86 <xQueueReceive+0x36>
     e6e:	9b01      	ldr	r3, [sp, #4]
     e70:	2b00      	cmp	r3, #0
     e72:	d00c      	beq.n	e8e <xQueueReceive+0x3e>
     e74:	b672      	cpsid	i
     e76:	e7fe      	b.n	e76 <xQueueReceive+0x26>
	configASSERT( ( pxQueue ) );
     e78:	b672      	cpsid	i
     e7a:	e7fe      	b.n	e7a <xQueueReceive+0x2a>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
     e7c:	6c03      	ldr	r3, [r0, #64]	; 0x40
     e7e:	2b00      	cmp	r3, #0
     e80:	d0f1      	beq.n	e66 <xQueueReceive+0x16>
     e82:	b672      	cpsid	i
     e84:	e7fe      	b.n	e84 <xQueueReceive+0x34>
     e86:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
     e88:	4b3a      	ldr	r3, [pc, #232]	; (f74 <xQueueReceive+0x124>)
     e8a:	4698      	mov	r8, r3
     e8c:	e02f      	b.n	eee <xQueueReceive+0x9e>
     e8e:	2600      	movs	r6, #0
     e90:	e7fa      	b.n	e88 <xQueueReceive+0x38>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
     e92:	0039      	movs	r1, r7
     e94:	0020      	movs	r0, r4
     e96:	4b38      	ldr	r3, [pc, #224]	; (f78 <xQueueReceive+0x128>)
     e98:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
     e9a:	3d01      	subs	r5, #1
     e9c:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e9e:	6923      	ldr	r3, [r4, #16]
     ea0:	2b00      	cmp	r3, #0
     ea2:	d007      	beq.n	eb4 <xQueueReceive+0x64>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ea4:	0020      	movs	r0, r4
     ea6:	3010      	adds	r0, #16
     ea8:	4b34      	ldr	r3, [pc, #208]	; (f7c <xQueueReceive+0x12c>)
     eaa:	4798      	blx	r3
     eac:	2800      	cmp	r0, #0
     eae:	d001      	beq.n	eb4 <xQueueReceive+0x64>
						queueYIELD_IF_USING_PREEMPTION();
     eb0:	4b33      	ldr	r3, [pc, #204]	; (f80 <xQueueReceive+0x130>)
     eb2:	4798      	blx	r3
				taskEXIT_CRITICAL();
     eb4:	4b33      	ldr	r3, [pc, #204]	; (f84 <xQueueReceive+0x134>)
     eb6:	4798      	blx	r3
				return pdPASS;
     eb8:	2001      	movs	r0, #1
}
     eba:	b004      	add	sp, #16
     ebc:	bc04      	pop	{r2}
     ebe:	4690      	mov	r8, r2
     ec0:	bdf0      	pop	{r4, r5, r6, r7, pc}
					taskEXIT_CRITICAL();
     ec2:	4b30      	ldr	r3, [pc, #192]	; (f84 <xQueueReceive+0x134>)
     ec4:	4798      	blx	r3
					return errQUEUE_EMPTY;
     ec6:	2000      	movs	r0, #0
     ec8:	e7f7      	b.n	eba <xQueueReceive+0x6a>
					vTaskInternalSetTimeOutState( &xTimeOut );
     eca:	a802      	add	r0, sp, #8
     ecc:	4b2e      	ldr	r3, [pc, #184]	; (f88 <xQueueReceive+0x138>)
     ece:	4798      	blx	r3
     ed0:	e016      	b.n	f00 <xQueueReceive+0xb0>
		prvLockQueue( pxQueue );
     ed2:	2200      	movs	r2, #0
     ed4:	2344      	movs	r3, #68	; 0x44
     ed6:	54e2      	strb	r2, [r4, r3]
     ed8:	e01d      	b.n	f16 <xQueueReceive+0xc6>
     eda:	2200      	movs	r2, #0
     edc:	2345      	movs	r3, #69	; 0x45
     ede:	54e2      	strb	r2, [r4, r3]
     ee0:	e01e      	b.n	f20 <xQueueReceive+0xd0>
				prvUnlockQueue( pxQueue );
     ee2:	0020      	movs	r0, r4
     ee4:	4b29      	ldr	r3, [pc, #164]	; (f8c <xQueueReceive+0x13c>)
     ee6:	4798      	blx	r3
				( void ) xTaskResumeAll();
     ee8:	4b29      	ldr	r3, [pc, #164]	; (f90 <xQueueReceive+0x140>)
     eea:	4798      	blx	r3
     eec:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
     eee:	47c0      	blx	r8
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     ef0:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     ef2:	2d00      	cmp	r5, #0
     ef4:	d1cd      	bne.n	e92 <xQueueReceive+0x42>
				if( xTicksToWait == ( TickType_t ) 0 )
     ef6:	9b01      	ldr	r3, [sp, #4]
     ef8:	2b00      	cmp	r3, #0
     efa:	d0e2      	beq.n	ec2 <xQueueReceive+0x72>
				else if( xEntryTimeSet == pdFALSE )
     efc:	2e00      	cmp	r6, #0
     efe:	d0e4      	beq.n	eca <xQueueReceive+0x7a>
		taskEXIT_CRITICAL();
     f00:	4b20      	ldr	r3, [pc, #128]	; (f84 <xQueueReceive+0x134>)
     f02:	4798      	blx	r3
		vTaskSuspendAll();
     f04:	4b23      	ldr	r3, [pc, #140]	; (f94 <xQueueReceive+0x144>)
     f06:	4798      	blx	r3
		prvLockQueue( pxQueue );
     f08:	4b1a      	ldr	r3, [pc, #104]	; (f74 <xQueueReceive+0x124>)
     f0a:	4798      	blx	r3
     f0c:	2344      	movs	r3, #68	; 0x44
     f0e:	5ce3      	ldrb	r3, [r4, r3]
     f10:	b25b      	sxtb	r3, r3
     f12:	3301      	adds	r3, #1
     f14:	d0dd      	beq.n	ed2 <xQueueReceive+0x82>
     f16:	2345      	movs	r3, #69	; 0x45
     f18:	5ce3      	ldrb	r3, [r4, r3]
     f1a:	b25b      	sxtb	r3, r3
     f1c:	3301      	adds	r3, #1
     f1e:	d0dc      	beq.n	eda <xQueueReceive+0x8a>
     f20:	4b18      	ldr	r3, [pc, #96]	; (f84 <xQueueReceive+0x134>)
     f22:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f24:	a901      	add	r1, sp, #4
     f26:	a802      	add	r0, sp, #8
     f28:	4b1b      	ldr	r3, [pc, #108]	; (f98 <xQueueReceive+0x148>)
     f2a:	4798      	blx	r3
     f2c:	2800      	cmp	r0, #0
     f2e:	d113      	bne.n	f58 <xQueueReceive+0x108>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     f30:	0020      	movs	r0, r4
     f32:	4b1a      	ldr	r3, [pc, #104]	; (f9c <xQueueReceive+0x14c>)
     f34:	4798      	blx	r3
     f36:	2800      	cmp	r0, #0
     f38:	d0d3      	beq.n	ee2 <xQueueReceive+0x92>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     f3a:	0020      	movs	r0, r4
     f3c:	3024      	adds	r0, #36	; 0x24
     f3e:	9901      	ldr	r1, [sp, #4]
     f40:	4b17      	ldr	r3, [pc, #92]	; (fa0 <xQueueReceive+0x150>)
     f42:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
     f44:	0020      	movs	r0, r4
     f46:	4b11      	ldr	r3, [pc, #68]	; (f8c <xQueueReceive+0x13c>)
     f48:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
     f4a:	4b11      	ldr	r3, [pc, #68]	; (f90 <xQueueReceive+0x140>)
     f4c:	4798      	blx	r3
     f4e:	2800      	cmp	r0, #0
     f50:	d1cc      	bne.n	eec <xQueueReceive+0x9c>
					portYIELD_WITHIN_API();
     f52:	4b0b      	ldr	r3, [pc, #44]	; (f80 <xQueueReceive+0x130>)
     f54:	4798      	blx	r3
     f56:	e7c9      	b.n	eec <xQueueReceive+0x9c>
			prvUnlockQueue( pxQueue );
     f58:	0020      	movs	r0, r4
     f5a:	4b0c      	ldr	r3, [pc, #48]	; (f8c <xQueueReceive+0x13c>)
     f5c:	4798      	blx	r3
			( void ) xTaskResumeAll();
     f5e:	4b0c      	ldr	r3, [pc, #48]	; (f90 <xQueueReceive+0x140>)
     f60:	4798      	blx	r3
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     f62:	0020      	movs	r0, r4
     f64:	4b0d      	ldr	r3, [pc, #52]	; (f9c <xQueueReceive+0x14c>)
     f66:	4798      	blx	r3
     f68:	2800      	cmp	r0, #0
     f6a:	d0bf      	beq.n	eec <xQueueReceive+0x9c>
				return errQUEUE_EMPTY;
     f6c:	2000      	movs	r0, #0
     f6e:	e7a4      	b.n	eba <xQueueReceive+0x6a>
     f70:	000017d5 	.word	0x000017d5
     f74:	00000891 	.word	0x00000891
     f78:	00000a55 	.word	0x00000a55
     f7c:	000016cd 	.word	0x000016cd
     f80:	00000879 	.word	0x00000879
     f84:	000008a9 	.word	0x000008a9
     f88:	0000174d 	.word	0x0000174d
     f8c:	00000a7d 	.word	0x00000a7d
     f90:	000014a1 	.word	0x000014a1
     f94:	00001375 	.word	0x00001375
     f98:	0000175d 	.word	0x0000175d
     f9c:	00000955 	.word	0x00000955
     fa0:	00001669 	.word	0x00001669

00000fa4 <vQueueAddToRegistry>:
	{
     fa4:	b510      	push	{r4, lr}
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
     fa6:	4b0a      	ldr	r3, [pc, #40]	; (fd0 <vQueueAddToRegistry+0x2c>)
     fa8:	681b      	ldr	r3, [r3, #0]
     faa:	2b00      	cmp	r3, #0
     fac:	d009      	beq.n	fc2 <vQueueAddToRegistry+0x1e>
     fae:	2301      	movs	r3, #1
     fb0:	4c07      	ldr	r4, [pc, #28]	; (fd0 <vQueueAddToRegistry+0x2c>)
     fb2:	00da      	lsls	r2, r3, #3
     fb4:	58a2      	ldr	r2, [r4, r2]
     fb6:	2a00      	cmp	r2, #0
     fb8:	d004      	beq.n	fc4 <vQueueAddToRegistry+0x20>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
     fba:	3301      	adds	r3, #1
     fbc:	2b08      	cmp	r3, #8
     fbe:	d1f8      	bne.n	fb2 <vQueueAddToRegistry+0xe>
	}
     fc0:	bd10      	pop	{r4, pc}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
     fc2:	2300      	movs	r3, #0
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
     fc4:	4a02      	ldr	r2, [pc, #8]	; (fd0 <vQueueAddToRegistry+0x2c>)
     fc6:	00db      	lsls	r3, r3, #3
     fc8:	5099      	str	r1, [r3, r2]
				xQueueRegistry[ ux ].xHandle = xQueue;
     fca:	18d3      	adds	r3, r2, r3
     fcc:	6058      	str	r0, [r3, #4]
				break;
     fce:	e7f7      	b.n	fc0 <vQueueAddToRegistry+0x1c>
     fd0:	20004458 	.word	0x20004458

00000fd4 <vQueueWaitForMessageRestricted>:
	{
     fd4:	b570      	push	{r4, r5, r6, lr}
     fd6:	0004      	movs	r4, r0
     fd8:	000d      	movs	r5, r1
     fda:	0016      	movs	r6, r2
		prvLockQueue( pxQueue );
     fdc:	4b11      	ldr	r3, [pc, #68]	; (1024 <vQueueWaitForMessageRestricted+0x50>)
     fde:	4798      	blx	r3
     fe0:	2344      	movs	r3, #68	; 0x44
     fe2:	5ce3      	ldrb	r3, [r4, r3]
     fe4:	b25b      	sxtb	r3, r3
     fe6:	3301      	adds	r3, #1
     fe8:	d00d      	beq.n	1006 <vQueueWaitForMessageRestricted+0x32>
     fea:	2345      	movs	r3, #69	; 0x45
     fec:	5ce3      	ldrb	r3, [r4, r3]
     fee:	b25b      	sxtb	r3, r3
     ff0:	3301      	adds	r3, #1
     ff2:	d00c      	beq.n	100e <vQueueWaitForMessageRestricted+0x3a>
     ff4:	4b0c      	ldr	r3, [pc, #48]	; (1028 <vQueueWaitForMessageRestricted+0x54>)
     ff6:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
     ff8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     ffa:	2b00      	cmp	r3, #0
     ffc:	d00b      	beq.n	1016 <vQueueWaitForMessageRestricted+0x42>
		prvUnlockQueue( pxQueue );
     ffe:	0020      	movs	r0, r4
    1000:	4b0a      	ldr	r3, [pc, #40]	; (102c <vQueueWaitForMessageRestricted+0x58>)
    1002:	4798      	blx	r3
	}
    1004:	bd70      	pop	{r4, r5, r6, pc}
		prvLockQueue( pxQueue );
    1006:	2200      	movs	r2, #0
    1008:	2344      	movs	r3, #68	; 0x44
    100a:	54e2      	strb	r2, [r4, r3]
    100c:	e7ed      	b.n	fea <vQueueWaitForMessageRestricted+0x16>
    100e:	2200      	movs	r2, #0
    1010:	2345      	movs	r3, #69	; 0x45
    1012:	54e2      	strb	r2, [r4, r3]
    1014:	e7ee      	b.n	ff4 <vQueueWaitForMessageRestricted+0x20>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1016:	0020      	movs	r0, r4
    1018:	3024      	adds	r0, #36	; 0x24
    101a:	0032      	movs	r2, r6
    101c:	0029      	movs	r1, r5
    101e:	4b04      	ldr	r3, [pc, #16]	; (1030 <vQueueWaitForMessageRestricted+0x5c>)
    1020:	4798      	blx	r3
    1022:	e7ec      	b.n	ffe <vQueueWaitForMessageRestricted+0x2a>
    1024:	00000891 	.word	0x00000891
    1028:	000008a9 	.word	0x000008a9
    102c:	00000a7d 	.word	0x00000a7d
    1030:	00001695 	.word	0x00001695

00001034 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1034:	4b08      	ldr	r3, [pc, #32]	; (1058 <prvResetNextTaskUnblockTime+0x24>)
    1036:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1038:	681b      	ldr	r3, [r3, #0]
    103a:	2b00      	cmp	r3, #0
    103c:	d006      	beq.n	104c <prvResetNextTaskUnblockTime+0x18>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    103e:	4b06      	ldr	r3, [pc, #24]	; (1058 <prvResetNextTaskUnblockTime+0x24>)
    1040:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    1042:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    1044:	68d2      	ldr	r2, [r2, #12]
    1046:	6852      	ldr	r2, [r2, #4]
    1048:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
    104a:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
    104c:	2201      	movs	r2, #1
    104e:	4252      	negs	r2, r2
    1050:	4b01      	ldr	r3, [pc, #4]	; (1058 <prvResetNextTaskUnblockTime+0x24>)
    1052:	62da      	str	r2, [r3, #44]	; 0x2c
    1054:	e7f9      	b.n	104a <prvResetNextTaskUnblockTime+0x16>
    1056:	46c0      	nop			; (mov r8, r8)
    1058:	20004318 	.word	0x20004318

0000105c <prvIdleTask>:
{
    105c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    105e:	46ce      	mov	lr, r9
    1060:	4647      	mov	r7, r8
    1062:	b580      	push	{r7, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    1064:	4b12      	ldr	r3, [pc, #72]	; (10b0 <prvIdleTask+0x54>)
    1066:	4698      	mov	r8, r3
			taskENTER_CRITICAL();
    1068:	4f12      	ldr	r7, [pc, #72]	; (10b4 <prvIdleTask+0x58>)
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    106a:	001c      	movs	r4, r3
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    106c:	4b12      	ldr	r3, [pc, #72]	; (10b8 <prvIdleTask+0x5c>)
    106e:	4699      	mov	r9, r3
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    1070:	4643      	mov	r3, r8
    1072:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    1074:	2b00      	cmp	r3, #0
    1076:	d014      	beq.n	10a2 <prvIdleTask+0x46>
			taskENTER_CRITICAL();
    1078:	47b8      	blx	r7
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    107a:	6c23      	ldr	r3, [r4, #64]	; 0x40
    107c:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    107e:	1d28      	adds	r0, r5, #4
    1080:	47c8      	blx	r9
				--uxCurrentNumberOfTasks;
    1082:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    1084:	3b01      	subs	r3, #1
    1086:	64a3      	str	r3, [r4, #72]	; 0x48
				--uxDeletedTasksWaitingCleanUp;
    1088:	6b23      	ldr	r3, [r4, #48]	; 0x30
    108a:	3b01      	subs	r3, #1
    108c:	6323      	str	r3, [r4, #48]	; 0x30
			taskEXIT_CRITICAL();
    108e:	4b0b      	ldr	r3, [pc, #44]	; (10bc <prvIdleTask+0x60>)
    1090:	4798      	blx	r3
			vPortFree( pxTCB->pxStack );
    1092:	6b28      	ldr	r0, [r5, #48]	; 0x30
    1094:	4e0a      	ldr	r6, [pc, #40]	; (10c0 <prvIdleTask+0x64>)
    1096:	47b0      	blx	r6
			vPortFree( pxTCB );
    1098:	0028      	movs	r0, r5
    109a:	47b0      	blx	r6
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    109c:	6b23      	ldr	r3, [r4, #48]	; 0x30
    109e:	2b00      	cmp	r3, #0
    10a0:	d1ea      	bne.n	1078 <prvIdleTask+0x1c>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    10a2:	4b03      	ldr	r3, [pc, #12]	; (10b0 <prvIdleTask+0x54>)
    10a4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    10a6:	2b01      	cmp	r3, #1
    10a8:	d9e2      	bls.n	1070 <prvIdleTask+0x14>
				taskYIELD();
    10aa:	4b06      	ldr	r3, [pc, #24]	; (10c4 <prvIdleTask+0x68>)
    10ac:	4798      	blx	r3
    10ae:	e7df      	b.n	1070 <prvIdleTask+0x14>
    10b0:	20004318 	.word	0x20004318
    10b4:	00000891 	.word	0x00000891
    10b8:	00000383 	.word	0x00000383
    10bc:	000008a9 	.word	0x000008a9
    10c0:	000002d9 	.word	0x000002d9
    10c4:	00000879 	.word	0x00000879

000010c8 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    10c8:	b570      	push	{r4, r5, r6, lr}
    10ca:	0004      	movs	r4, r0
    10cc:	000d      	movs	r5, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    10ce:	4b15      	ldr	r3, [pc, #84]	; (1124 <prvAddCurrentTaskToDelayedList+0x5c>)
    10d0:	6b1e      	ldr	r6, [r3, #48]	; 0x30
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    10d2:	6b58      	ldr	r0, [r3, #52]	; 0x34
    10d4:	3004      	adds	r0, #4
    10d6:	4b14      	ldr	r3, [pc, #80]	; (1128 <prvAddCurrentTaskToDelayedList+0x60>)
    10d8:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    10da:	1c63      	adds	r3, r4, #1
    10dc:	d012      	beq.n	1104 <prvAddCurrentTaskToDelayedList+0x3c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    10de:	1934      	adds	r4, r6, r4

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    10e0:	4b10      	ldr	r3, [pc, #64]	; (1124 <prvAddCurrentTaskToDelayedList+0x5c>)
    10e2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    10e4:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
    10e6:	42a6      	cmp	r6, r4
    10e8:	d815      	bhi.n	1116 <prvAddCurrentTaskToDelayedList+0x4e>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    10ea:	4d10      	ldr	r5, [pc, #64]	; (112c <prvAddCurrentTaskToDelayedList+0x64>)
    10ec:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    10ee:	4b0d      	ldr	r3, [pc, #52]	; (1124 <prvAddCurrentTaskToDelayedList+0x5c>)
    10f0:	6b59      	ldr	r1, [r3, #52]	; 0x34
    10f2:	3104      	adds	r1, #4
    10f4:	4b0e      	ldr	r3, [pc, #56]	; (1130 <prvAddCurrentTaskToDelayedList+0x68>)
    10f6:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    10f8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    10fa:	429c      	cmp	r4, r3
    10fc:	d211      	bcs.n	1122 <prvAddCurrentTaskToDelayedList+0x5a>
				{
					xNextTaskUnblockTime = xTimeToWake;
    10fe:	4b0b      	ldr	r3, [pc, #44]	; (112c <prvAddCurrentTaskToDelayedList+0x64>)
    1100:	62dc      	str	r4, [r3, #44]	; 0x2c

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1102:	e00e      	b.n	1122 <prvAddCurrentTaskToDelayedList+0x5a>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    1104:	2d00      	cmp	r5, #0
    1106:	d0ea      	beq.n	10de <prvAddCurrentTaskToDelayedList+0x16>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1108:	4b06      	ldr	r3, [pc, #24]	; (1124 <prvAddCurrentTaskToDelayedList+0x5c>)
    110a:	6b59      	ldr	r1, [r3, #52]	; 0x34
    110c:	3104      	adds	r1, #4
    110e:	4807      	ldr	r0, [pc, #28]	; (112c <prvAddCurrentTaskToDelayedList+0x64>)
    1110:	4b08      	ldr	r3, [pc, #32]	; (1134 <prvAddCurrentTaskToDelayedList+0x6c>)
    1112:	4798      	blx	r3
    1114:	e005      	b.n	1122 <prvAddCurrentTaskToDelayedList+0x5a>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1116:	4b03      	ldr	r3, [pc, #12]	; (1124 <prvAddCurrentTaskToDelayedList+0x5c>)
    1118:	6b98      	ldr	r0, [r3, #56]	; 0x38
    111a:	6b59      	ldr	r1, [r3, #52]	; 0x34
    111c:	3104      	adds	r1, #4
    111e:	4b04      	ldr	r3, [pc, #16]	; (1130 <prvAddCurrentTaskToDelayedList+0x68>)
    1120:	4798      	blx	r3
}
    1122:	bd70      	pop	{r4, r5, r6, pc}
    1124:	20004398 	.word	0x20004398
    1128:	00000383 	.word	0x00000383
    112c:	20004318 	.word	0x20004318
    1130:	00000355 	.word	0x00000355
    1134:	0000033d 	.word	0x0000033d

00001138 <xTaskCreate>:
	{
    1138:	b5f0      	push	{r4, r5, r6, r7, lr}
    113a:	46d6      	mov	lr, sl
    113c:	464f      	mov	r7, r9
    113e:	4646      	mov	r6, r8
    1140:	b5c0      	push	{r6, r7, lr}
    1142:	b084      	sub	sp, #16
    1144:	9001      	str	r0, [sp, #4]
    1146:	000d      	movs	r5, r1
    1148:	9302      	str	r3, [sp, #8]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    114a:	0097      	lsls	r7, r2, #2
    114c:	0038      	movs	r0, r7
    114e:	4b63      	ldr	r3, [pc, #396]	; (12dc <xTaskCreate+0x1a4>)
    1150:	4798      	blx	r3
    1152:	1e06      	subs	r6, r0, #0
			if( pxStack != NULL )
    1154:	d100      	bne.n	1158 <xTaskCreate+0x20>
    1156:	e089      	b.n	126c <xTaskCreate+0x134>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    1158:	2054      	movs	r0, #84	; 0x54
    115a:	4b60      	ldr	r3, [pc, #384]	; (12dc <xTaskCreate+0x1a4>)
    115c:	4798      	blx	r3
    115e:	1e04      	subs	r4, r0, #0
				if( pxNewTCB != NULL )
    1160:	d100      	bne.n	1164 <xTaskCreate+0x2c>
    1162:	e080      	b.n	1266 <xTaskCreate+0x12e>
					pxNewTCB->pxStack = pxStack;
    1164:	6306      	str	r6, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    1166:	003a      	movs	r2, r7
    1168:	21a5      	movs	r1, #165	; 0xa5
    116a:	0030      	movs	r0, r6
    116c:	4b5c      	ldr	r3, [pc, #368]	; (12e0 <xTaskCreate+0x1a8>)
    116e:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    1170:	1f3a      	subs	r2, r7, #4
    1172:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1174:	469c      	mov	ip, r3
    1176:	4462      	add	r2, ip
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    1178:	2307      	movs	r3, #7
    117a:	439a      	bics	r2, r3
    117c:	4690      	mov	r8, r2
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    117e:	782a      	ldrb	r2, [r5, #0]
    1180:	332d      	adds	r3, #45	; 0x2d
    1182:	54e2      	strb	r2, [r4, r3]
		if( pcName[ x ] == 0x00 )
    1184:	782b      	ldrb	r3, [r5, #0]
    1186:	2b00      	cmp	r3, #0
    1188:	d00c      	beq.n	11a4 <xTaskCreate+0x6c>
    118a:	1c6b      	adds	r3, r5, #1
    118c:	0022      	movs	r2, r4
    118e:	3235      	adds	r2, #53	; 0x35
    1190:	3505      	adds	r5, #5
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1192:	7819      	ldrb	r1, [r3, #0]
    1194:	7011      	strb	r1, [r2, #0]
		if( pcName[ x ] == 0x00 )
    1196:	7819      	ldrb	r1, [r3, #0]
    1198:	2900      	cmp	r1, #0
    119a:	d003      	beq.n	11a4 <xTaskCreate+0x6c>
    119c:	3301      	adds	r3, #1
    119e:	3201      	adds	r2, #1
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    11a0:	42ab      	cmp	r3, r5
    11a2:	d1f6      	bne.n	1192 <xTaskCreate+0x5a>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    11a4:	2200      	movs	r2, #0
    11a6:	2338      	movs	r3, #56	; 0x38
    11a8:	54e2      	strb	r2, [r4, r3]
    11aa:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    11ac:	2f04      	cmp	r7, #4
    11ae:	d900      	bls.n	11b2 <xTaskCreate+0x7a>
    11b0:	2704      	movs	r7, #4
	pxNewTCB->uxPriority = uxPriority;
    11b2:	62e7      	str	r7, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
    11b4:	6467      	str	r7, [r4, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
    11b6:	2600      	movs	r6, #0
    11b8:	64a6      	str	r6, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    11ba:	1d23      	adds	r3, r4, #4
    11bc:	9303      	str	r3, [sp, #12]
    11be:	0018      	movs	r0, r3
    11c0:	4d48      	ldr	r5, [pc, #288]	; (12e4 <xTaskCreate+0x1ac>)
    11c2:	47a8      	blx	r5
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    11c4:	0020      	movs	r0, r4
    11c6:	3018      	adds	r0, #24
    11c8:	47a8      	blx	r5
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    11ca:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    11cc:	2305      	movs	r3, #5
    11ce:	1bdb      	subs	r3, r3, r7
    11d0:	61a3      	str	r3, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    11d2:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
    11d4:	64e6      	str	r6, [r4, #76]	; 0x4c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    11d6:	2350      	movs	r3, #80	; 0x50
    11d8:	54e6      	strb	r6, [r4, r3]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    11da:	9a02      	ldr	r2, [sp, #8]
    11dc:	9901      	ldr	r1, [sp, #4]
    11de:	4640      	mov	r0, r8
    11e0:	4b41      	ldr	r3, [pc, #260]	; (12e8 <xTaskCreate+0x1b0>)
    11e2:	4798      	blx	r3
    11e4:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
    11e6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    11e8:	2b00      	cmp	r3, #0
    11ea:	d000      	beq.n	11ee <xTaskCreate+0xb6>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    11ec:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
    11ee:	4b3f      	ldr	r3, [pc, #252]	; (12ec <xTaskCreate+0x1b4>)
    11f0:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
    11f2:	4a3f      	ldr	r2, [pc, #252]	; (12f0 <xTaskCreate+0x1b8>)
    11f4:	6c93      	ldr	r3, [r2, #72]	; 0x48
    11f6:	3301      	adds	r3, #1
    11f8:	6493      	str	r3, [r2, #72]	; 0x48
		if( pxCurrentTCB == NULL )
    11fa:	4b3e      	ldr	r3, [pc, #248]	; (12f4 <xTaskCreate+0x1bc>)
    11fc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    11fe:	2b00      	cmp	r3, #0
    1200:	d037      	beq.n	1272 <xTaskCreate+0x13a>
			if( xSchedulerRunning == pdFALSE )
    1202:	4b3c      	ldr	r3, [pc, #240]	; (12f4 <xTaskCreate+0x1bc>)
    1204:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    1206:	2b00      	cmp	r3, #0
    1208:	d107      	bne.n	121a <xTaskCreate+0xe2>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    120a:	4b3a      	ldr	r3, [pc, #232]	; (12f4 <xTaskCreate+0x1bc>)
    120c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    120e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1210:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1212:	4293      	cmp	r3, r2
    1214:	d801      	bhi.n	121a <xTaskCreate+0xe2>
					pxCurrentTCB = pxNewTCB;
    1216:	4b37      	ldr	r3, [pc, #220]	; (12f4 <xTaskCreate+0x1bc>)
    1218:	635c      	str	r4, [r3, #52]	; 0x34
		uxTaskNumber++;
    121a:	4936      	ldr	r1, [pc, #216]	; (12f4 <xTaskCreate+0x1bc>)
    121c:	6e8b      	ldr	r3, [r1, #104]	; 0x68
    121e:	3301      	adds	r3, #1
    1220:	668b      	str	r3, [r1, #104]	; 0x68
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    1222:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList( pxNewTCB );
    1224:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1226:	6ecb      	ldr	r3, [r1, #108]	; 0x6c
    1228:	429a      	cmp	r2, r3
    122a:	d900      	bls.n	122e <xTaskCreate+0xf6>
    122c:	66ca      	str	r2, [r1, #108]	; 0x6c
    122e:	0090      	lsls	r0, r2, #2
    1230:	1882      	adds	r2, r0, r2
    1232:	0092      	lsls	r2, r2, #2
    1234:	482e      	ldr	r0, [pc, #184]	; (12f0 <xTaskCreate+0x1b8>)
    1236:	304c      	adds	r0, #76	; 0x4c
    1238:	1880      	adds	r0, r0, r2
    123a:	9903      	ldr	r1, [sp, #12]
    123c:	4b2e      	ldr	r3, [pc, #184]	; (12f8 <xTaskCreate+0x1c0>)
    123e:	4798      	blx	r3
	taskEXIT_CRITICAL();
    1240:	4b2e      	ldr	r3, [pc, #184]	; (12fc <xTaskCreate+0x1c4>)
    1242:	4798      	blx	r3
	if( xSchedulerRunning != pdFALSE )
    1244:	4b2b      	ldr	r3, [pc, #172]	; (12f4 <xTaskCreate+0x1bc>)
    1246:	6e5b      	ldr	r3, [r3, #100]	; 0x64
			xReturn = pdPASS;
    1248:	2001      	movs	r0, #1
	if( xSchedulerRunning != pdFALSE )
    124a:	2b00      	cmp	r3, #0
    124c:	d005      	beq.n	125a <xTaskCreate+0x122>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    124e:	4b29      	ldr	r3, [pc, #164]	; (12f4 <xTaskCreate+0x1bc>)
    1250:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1252:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1254:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    1256:	429a      	cmp	r2, r3
    1258:	d33b      	bcc.n	12d2 <xTaskCreate+0x19a>
	}
    125a:	b004      	add	sp, #16
    125c:	bc1c      	pop	{r2, r3, r4}
    125e:	4690      	mov	r8, r2
    1260:	4699      	mov	r9, r3
    1262:	46a2      	mov	sl, r4
    1264:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vPortFree( pxStack );
    1266:	0030      	movs	r0, r6
    1268:	4b25      	ldr	r3, [pc, #148]	; (1300 <xTaskCreate+0x1c8>)
    126a:	4798      	blx	r3
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    126c:	2001      	movs	r0, #1
    126e:	4240      	negs	r0, r0
    1270:	e7f3      	b.n	125a <xTaskCreate+0x122>
			pxCurrentTCB = pxNewTCB;
    1272:	4b20      	ldr	r3, [pc, #128]	; (12f4 <xTaskCreate+0x1bc>)
    1274:	635c      	str	r4, [r3, #52]	; 0x34
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1276:	6c93      	ldr	r3, [r2, #72]	; 0x48
    1278:	2b01      	cmp	r3, #1
    127a:	d1ce      	bne.n	121a <xTaskCreate+0xe2>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    127c:	0017      	movs	r7, r2
    127e:	0010      	movs	r0, r2
    1280:	304c      	adds	r0, #76	; 0x4c
    1282:	4e20      	ldr	r6, [pc, #128]	; (1304 <xTaskCreate+0x1cc>)
    1284:	47b0      	blx	r6
    1286:	0038      	movs	r0, r7
    1288:	3060      	adds	r0, #96	; 0x60
    128a:	47b0      	blx	r6
    128c:	0038      	movs	r0, r7
    128e:	3074      	adds	r0, #116	; 0x74
    1290:	47b0      	blx	r6
    1292:	0038      	movs	r0, r7
    1294:	3088      	adds	r0, #136	; 0x88
    1296:	47b0      	blx	r6
    1298:	0038      	movs	r0, r7
    129a:	309c      	adds	r0, #156	; 0x9c
    129c:	47b0      	blx	r6
	vListInitialise( &xDelayedTaskList1 );
    129e:	4b15      	ldr	r3, [pc, #84]	; (12f4 <xTaskCreate+0x1bc>)
    12a0:	4698      	mov	r8, r3
    12a2:	233c      	movs	r3, #60	; 0x3c
    12a4:	4443      	add	r3, r8
    12a6:	469a      	mov	sl, r3
    12a8:	0018      	movs	r0, r3
    12aa:	47b0      	blx	r6
	vListInitialise( &xDelayedTaskList2 );
    12ac:	2350      	movs	r3, #80	; 0x50
    12ae:	4443      	add	r3, r8
    12b0:	4699      	mov	r9, r3
    12b2:	0018      	movs	r0, r3
    12b4:	47b0      	blx	r6
	vListInitialise( &xPendingReadyList );
    12b6:	0038      	movs	r0, r7
    12b8:	3014      	adds	r0, #20
    12ba:	47b0      	blx	r6
		vListInitialise( &xTasksWaitingTermination );
    12bc:	0038      	movs	r0, r7
    12be:	3034      	adds	r0, #52	; 0x34
    12c0:	47b0      	blx	r6
		vListInitialise( &xSuspendedTaskList );
    12c2:	0038      	movs	r0, r7
    12c4:	47b0      	blx	r6
	pxDelayedTaskList = &xDelayedTaskList1;
    12c6:	4653      	mov	r3, sl
    12c8:	62bb      	str	r3, [r7, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    12ca:	4643      	mov	r3, r8
    12cc:	464a      	mov	r2, r9
    12ce:	639a      	str	r2, [r3, #56]	; 0x38
    12d0:	e7a3      	b.n	121a <xTaskCreate+0xe2>
			taskYIELD_IF_USING_PREEMPTION();
    12d2:	4b0d      	ldr	r3, [pc, #52]	; (1308 <xTaskCreate+0x1d0>)
    12d4:	4798      	blx	r3
			xReturn = pdPASS;
    12d6:	2001      	movs	r0, #1
    12d8:	e7bf      	b.n	125a <xTaskCreate+0x122>
    12da:	46c0      	nop			; (mov r8, r8)
    12dc:	0000020d 	.word	0x0000020d
    12e0:	00001d5d 	.word	0x00001d5d
    12e4:	00000337 	.word	0x00000337
    12e8:	000007f5 	.word	0x000007f5
    12ec:	00000891 	.word	0x00000891
    12f0:	20004318 	.word	0x20004318
    12f4:	20004398 	.word	0x20004398
    12f8:	0000033d 	.word	0x0000033d
    12fc:	000008a9 	.word	0x000008a9
    1300:	000002d9 	.word	0x000002d9
    1304:	00000321 	.word	0x00000321
    1308:	00000879 	.word	0x00000879

0000130c <vTaskStartScheduler>:
{
    130c:	b510      	push	{r4, lr}
    130e:	b082      	sub	sp, #8
		xReturn = xTaskCreate(	prvIdleTask,
    1310:	4b11      	ldr	r3, [pc, #68]	; (1358 <vTaskStartScheduler+0x4c>)
    1312:	3374      	adds	r3, #116	; 0x74
    1314:	9301      	str	r3, [sp, #4]
    1316:	2300      	movs	r3, #0
    1318:	9300      	str	r3, [sp, #0]
    131a:	2246      	movs	r2, #70	; 0x46
    131c:	490f      	ldr	r1, [pc, #60]	; (135c <vTaskStartScheduler+0x50>)
    131e:	4810      	ldr	r0, [pc, #64]	; (1360 <vTaskStartScheduler+0x54>)
    1320:	4c10      	ldr	r4, [pc, #64]	; (1364 <vTaskStartScheduler+0x58>)
    1322:	47a0      	blx	r4
		if( xReturn == pdPASS )
    1324:	2801      	cmp	r0, #1
    1326:	d003      	beq.n	1330 <vTaskStartScheduler+0x24>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    1328:	1c43      	adds	r3, r0, #1
    132a:	d012      	beq.n	1352 <vTaskStartScheduler+0x46>
}
    132c:	b002      	add	sp, #8
    132e:	bd10      	pop	{r4, pc}
			xReturn = xTimerCreateTimerTask();
    1330:	4b0d      	ldr	r3, [pc, #52]	; (1368 <vTaskStartScheduler+0x5c>)
    1332:	4798      	blx	r3
	if( xReturn == pdPASS )
    1334:	2801      	cmp	r0, #1
    1336:	d1f7      	bne.n	1328 <vTaskStartScheduler+0x1c>
		portDISABLE_INTERRUPTS();
    1338:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
    133a:	2201      	movs	r2, #1
    133c:	4252      	negs	r2, r2
    133e:	4b0b      	ldr	r3, [pc, #44]	; (136c <vTaskStartScheduler+0x60>)
    1340:	62da      	str	r2, [r3, #44]	; 0x2c
		xSchedulerRunning = pdTRUE;
    1342:	4b05      	ldr	r3, [pc, #20]	; (1358 <vTaskStartScheduler+0x4c>)
    1344:	3202      	adds	r2, #2
    1346:	665a      	str	r2, [r3, #100]	; 0x64
		xTickCount = ( TickType_t ) 0U;
    1348:	2200      	movs	r2, #0
    134a:	631a      	str	r2, [r3, #48]	; 0x30
		if( xPortStartScheduler() != pdFALSE )
    134c:	4b08      	ldr	r3, [pc, #32]	; (1370 <vTaskStartScheduler+0x64>)
    134e:	4798      	blx	r3
    1350:	e7ec      	b.n	132c <vTaskStartScheduler+0x20>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    1352:	b672      	cpsid	i
    1354:	e7fe      	b.n	1354 <vTaskStartScheduler+0x48>
    1356:	46c0      	nop			; (mov r8, r8)
    1358:	20004398 	.word	0x20004398
    135c:	00001fe0 	.word	0x00001fe0
    1360:	0000105d 	.word	0x0000105d
    1364:	00001139 	.word	0x00001139
    1368:	00001911 	.word	0x00001911
    136c:	20004318 	.word	0x20004318
    1370:	00000815 	.word	0x00000815

00001374 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    1374:	4a02      	ldr	r2, [pc, #8]	; (1380 <vTaskSuspendAll+0xc>)
    1376:	6f13      	ldr	r3, [r2, #112]	; 0x70
    1378:	3301      	adds	r3, #1
    137a:	6713      	str	r3, [r2, #112]	; 0x70
}
    137c:	4770      	bx	lr
    137e:	46c0      	nop			; (mov r8, r8)
    1380:	20004398 	.word	0x20004398

00001384 <xTaskGetTickCount>:
		xTicks = xTickCount;
    1384:	4b01      	ldr	r3, [pc, #4]	; (138c <xTaskGetTickCount+0x8>)
    1386:	6b18      	ldr	r0, [r3, #48]	; 0x30
}
    1388:	4770      	bx	lr
    138a:	46c0      	nop			; (mov r8, r8)
    138c:	20004398 	.word	0x20004398

00001390 <xTaskIncrementTick>:
{
    1390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1392:	46ce      	mov	lr, r9
    1394:	4647      	mov	r7, r8
    1396:	b580      	push	{r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1398:	4b3b      	ldr	r3, [pc, #236]	; (1488 <xTaskIncrementTick+0xf8>)
    139a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    139c:	2b00      	cmp	r3, #0
    139e:	d164      	bne.n	146a <xTaskIncrementTick+0xda>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    13a0:	4b39      	ldr	r3, [pc, #228]	; (1488 <xTaskIncrementTick+0xf8>)
    13a2:	6b1e      	ldr	r6, [r3, #48]	; 0x30
    13a4:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
    13a6:	631e      	str	r6, [r3, #48]	; 0x30
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    13a8:	2e00      	cmp	r6, #0
    13aa:	d111      	bne.n	13d0 <xTaskIncrementTick+0x40>
			taskSWITCH_DELAYED_LISTS();
    13ac:	4b37      	ldr	r3, [pc, #220]	; (148c <xTaskIncrementTick+0xfc>)
    13ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    13b0:	681b      	ldr	r3, [r3, #0]
    13b2:	2b00      	cmp	r3, #0
    13b4:	d001      	beq.n	13ba <xTaskIncrementTick+0x2a>
    13b6:	b672      	cpsid	i
    13b8:	e7fe      	b.n	13b8 <xTaskIncrementTick+0x28>
    13ba:	4a34      	ldr	r2, [pc, #208]	; (148c <xTaskIncrementTick+0xfc>)
    13bc:	6a91      	ldr	r1, [r2, #40]	; 0x28
    13be:	4b32      	ldr	r3, [pc, #200]	; (1488 <xTaskIncrementTick+0xf8>)
    13c0:	6b98      	ldr	r0, [r3, #56]	; 0x38
    13c2:	6290      	str	r0, [r2, #40]	; 0x28
    13c4:	6399      	str	r1, [r3, #56]	; 0x38
    13c6:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    13c8:	3201      	adds	r2, #1
    13ca:	679a      	str	r2, [r3, #120]	; 0x78
    13cc:	4b30      	ldr	r3, [pc, #192]	; (1490 <xTaskIncrementTick+0x100>)
    13ce:	4798      	blx	r3
		if( xConstTickCount >= xNextTaskUnblockTime )
    13d0:	4b2e      	ldr	r3, [pc, #184]	; (148c <xTaskIncrementTick+0xfc>)
    13d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
BaseType_t xSwitchRequired = pdFALSE;
    13d4:	2400      	movs	r4, #0
		if( xConstTickCount >= xNextTaskUnblockTime )
    13d6:	429e      	cmp	r6, r3
    13d8:	d337      	bcc.n	144a <xTaskIncrementTick+0xba>
    13da:	2400      	movs	r4, #0
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    13dc:	4b2b      	ldr	r3, [pc, #172]	; (148c <xTaskIncrementTick+0xfc>)
    13de:	4699      	mov	r9, r3
					prvAddTaskToReadyList( pxTCB );
    13e0:	224c      	movs	r2, #76	; 0x4c
    13e2:	4694      	mov	ip, r2
    13e4:	4463      	add	r3, ip
    13e6:	4698      	mov	r8, r3
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    13e8:	464b      	mov	r3, r9
    13ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    13ec:	681b      	ldr	r3, [r3, #0]
    13ee:	2b00      	cmp	r3, #0
    13f0:	d027      	beq.n	1442 <xTaskIncrementTick+0xb2>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    13f2:	4b26      	ldr	r3, [pc, #152]	; (148c <xTaskIncrementTick+0xfc>)
    13f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    13f6:	68db      	ldr	r3, [r3, #12]
    13f8:	68df      	ldr	r7, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    13fa:	687b      	ldr	r3, [r7, #4]
					if( xConstTickCount < xItemValue )
    13fc:	429e      	cmp	r6, r3
    13fe:	d331      	bcc.n	1464 <xTaskIncrementTick+0xd4>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1400:	1d3d      	adds	r5, r7, #4
    1402:	0028      	movs	r0, r5
    1404:	4b23      	ldr	r3, [pc, #140]	; (1494 <xTaskIncrementTick+0x104>)
    1406:	4798      	blx	r3
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1408:	6abb      	ldr	r3, [r7, #40]	; 0x28
    140a:	2b00      	cmp	r3, #0
    140c:	d003      	beq.n	1416 <xTaskIncrementTick+0x86>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    140e:	0038      	movs	r0, r7
    1410:	3018      	adds	r0, #24
    1412:	4b20      	ldr	r3, [pc, #128]	; (1494 <xTaskIncrementTick+0x104>)
    1414:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
    1416:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1418:	4a1b      	ldr	r2, [pc, #108]	; (1488 <xTaskIncrementTick+0xf8>)
    141a:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
    141c:	4293      	cmp	r3, r2
    141e:	d901      	bls.n	1424 <xTaskIncrementTick+0x94>
    1420:	4a19      	ldr	r2, [pc, #100]	; (1488 <xTaskIncrementTick+0xf8>)
    1422:	66d3      	str	r3, [r2, #108]	; 0x6c
    1424:	0098      	lsls	r0, r3, #2
    1426:	18c0      	adds	r0, r0, r3
    1428:	0080      	lsls	r0, r0, #2
    142a:	4440      	add	r0, r8
    142c:	0029      	movs	r1, r5
    142e:	4b1a      	ldr	r3, [pc, #104]	; (1498 <xTaskIncrementTick+0x108>)
    1430:	4798      	blx	r3
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1432:	4b15      	ldr	r3, [pc, #84]	; (1488 <xTaskIncrementTick+0xf8>)
    1434:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1436:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    1438:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    143a:	429a      	cmp	r2, r3
    143c:	d3d4      	bcc.n	13e8 <xTaskIncrementTick+0x58>
							xSwitchRequired = pdTRUE;
    143e:	2401      	movs	r4, #1
    1440:	e7d2      	b.n	13e8 <xTaskIncrementTick+0x58>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1442:	2201      	movs	r2, #1
    1444:	4252      	negs	r2, r2
    1446:	4b11      	ldr	r3, [pc, #68]	; (148c <xTaskIncrementTick+0xfc>)
    1448:	62da      	str	r2, [r3, #44]	; 0x2c
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    144a:	4b0f      	ldr	r3, [pc, #60]	; (1488 <xTaskIncrementTick+0xf8>)
    144c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    144e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1450:	0093      	lsls	r3, r2, #2
    1452:	189b      	adds	r3, r3, r2
    1454:	009b      	lsls	r3, r3, #2
    1456:	4a0d      	ldr	r2, [pc, #52]	; (148c <xTaskIncrementTick+0xfc>)
    1458:	18d3      	adds	r3, r2, r3
    145a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    145c:	2b01      	cmp	r3, #1
    145e:	d909      	bls.n	1474 <xTaskIncrementTick+0xe4>
				xSwitchRequired = pdTRUE;
    1460:	2401      	movs	r4, #1
    1462:	e007      	b.n	1474 <xTaskIncrementTick+0xe4>
						xNextTaskUnblockTime = xItemValue;
    1464:	4a09      	ldr	r2, [pc, #36]	; (148c <xTaskIncrementTick+0xfc>)
    1466:	62d3      	str	r3, [r2, #44]	; 0x2c
						break;
    1468:	e7ef      	b.n	144a <xTaskIncrementTick+0xba>
		++uxPendedTicks;
    146a:	4a07      	ldr	r2, [pc, #28]	; (1488 <xTaskIncrementTick+0xf8>)
    146c:	6fd3      	ldr	r3, [r2, #124]	; 0x7c
    146e:	3301      	adds	r3, #1
    1470:	67d3      	str	r3, [r2, #124]	; 0x7c
BaseType_t xSwitchRequired = pdFALSE;
    1472:	2400      	movs	r4, #0
		if( xYieldPending != pdFALSE )
    1474:	4b09      	ldr	r3, [pc, #36]	; (149c <xTaskIncrementTick+0x10c>)
    1476:	681b      	ldr	r3, [r3, #0]
    1478:	2b00      	cmp	r3, #0
    147a:	d000      	beq.n	147e <xTaskIncrementTick+0xee>
			xSwitchRequired = pdTRUE;
    147c:	2401      	movs	r4, #1
}
    147e:	0020      	movs	r0, r4
    1480:	bc0c      	pop	{r2, r3}
    1482:	4690      	mov	r8, r2
    1484:	4699      	mov	r9, r3
    1486:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1488:	20004398 	.word	0x20004398
    148c:	20004318 	.word	0x20004318
    1490:	00001035 	.word	0x00001035
    1494:	00000383 	.word	0x00000383
    1498:	0000033d 	.word	0x0000033d
    149c:	20004418 	.word	0x20004418

000014a0 <xTaskResumeAll>:
{
    14a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    14a2:	b083      	sub	sp, #12
	configASSERT( uxSchedulerSuspended );
    14a4:	4b31      	ldr	r3, [pc, #196]	; (156c <xTaskResumeAll+0xcc>)
    14a6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    14a8:	2b00      	cmp	r3, #0
    14aa:	d101      	bne.n	14b0 <xTaskResumeAll+0x10>
    14ac:	b672      	cpsid	i
    14ae:	e7fe      	b.n	14ae <xTaskResumeAll+0xe>
	taskENTER_CRITICAL();
    14b0:	4b2f      	ldr	r3, [pc, #188]	; (1570 <xTaskResumeAll+0xd0>)
    14b2:	4798      	blx	r3
		--uxSchedulerSuspended;
    14b4:	4b2d      	ldr	r3, [pc, #180]	; (156c <xTaskResumeAll+0xcc>)
    14b6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    14b8:	3a01      	subs	r2, #1
    14ba:	671a      	str	r2, [r3, #112]	; 0x70
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    14bc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
BaseType_t xAlreadyYielded = pdFALSE;
    14be:	2400      	movs	r4, #0
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    14c0:	2b00      	cmp	r3, #0
    14c2:	d104      	bne.n	14ce <xTaskResumeAll+0x2e>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    14c4:	4b2b      	ldr	r3, [pc, #172]	; (1574 <xTaskResumeAll+0xd4>)
    14c6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    14c8:	2500      	movs	r5, #0
    14ca:	2b00      	cmp	r3, #0
    14cc:	d104      	bne.n	14d8 <xTaskResumeAll+0x38>
	taskEXIT_CRITICAL();
    14ce:	4b2a      	ldr	r3, [pc, #168]	; (1578 <xTaskResumeAll+0xd8>)
    14d0:	4798      	blx	r3
}
    14d2:	0020      	movs	r0, r4
    14d4:	b003      	add	sp, #12
    14d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    14d8:	4f26      	ldr	r7, [pc, #152]	; (1574 <xTaskResumeAll+0xd4>)
					prvAddTaskToReadyList( pxTCB );
    14da:	003e      	movs	r6, r7
    14dc:	364c      	adds	r6, #76	; 0x4c
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    14de:	697b      	ldr	r3, [r7, #20]
    14e0:	2b00      	cmp	r3, #0
    14e2:	d022      	beq.n	152a <xTaskResumeAll+0x8a>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    14e4:	4b23      	ldr	r3, [pc, #140]	; (1574 <xTaskResumeAll+0xd4>)
    14e6:	6a1b      	ldr	r3, [r3, #32]
    14e8:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    14ea:	0028      	movs	r0, r5
    14ec:	3018      	adds	r0, #24
    14ee:	4c23      	ldr	r4, [pc, #140]	; (157c <xTaskResumeAll+0xdc>)
    14f0:	47a0      	blx	r4
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    14f2:	1d2b      	adds	r3, r5, #4
    14f4:	9301      	str	r3, [sp, #4]
    14f6:	0018      	movs	r0, r3
    14f8:	47a0      	blx	r4
					prvAddTaskToReadyList( pxTCB );
    14fa:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    14fc:	4a1b      	ldr	r2, [pc, #108]	; (156c <xTaskResumeAll+0xcc>)
    14fe:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
    1500:	4293      	cmp	r3, r2
    1502:	d901      	bls.n	1508 <xTaskResumeAll+0x68>
    1504:	4a19      	ldr	r2, [pc, #100]	; (156c <xTaskResumeAll+0xcc>)
    1506:	66d3      	str	r3, [r2, #108]	; 0x6c
    1508:	0098      	lsls	r0, r3, #2
    150a:	18c0      	adds	r0, r0, r3
    150c:	0080      	lsls	r0, r0, #2
    150e:	1830      	adds	r0, r6, r0
    1510:	9901      	ldr	r1, [sp, #4]
    1512:	4b1b      	ldr	r3, [pc, #108]	; (1580 <xTaskResumeAll+0xe0>)
    1514:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1516:	4b15      	ldr	r3, [pc, #84]	; (156c <xTaskResumeAll+0xcc>)
    1518:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    151a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    151c:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    151e:	429a      	cmp	r2, r3
    1520:	d3dd      	bcc.n	14de <xTaskResumeAll+0x3e>
						xYieldPending = pdTRUE;
    1522:	2201      	movs	r2, #1
    1524:	4b17      	ldr	r3, [pc, #92]	; (1584 <xTaskResumeAll+0xe4>)
    1526:	601a      	str	r2, [r3, #0]
    1528:	e7d9      	b.n	14de <xTaskResumeAll+0x3e>
				if( pxTCB != NULL )
    152a:	2d00      	cmp	r5, #0
    152c:	d001      	beq.n	1532 <xTaskResumeAll+0x92>
					prvResetNextTaskUnblockTime();
    152e:	4b16      	ldr	r3, [pc, #88]	; (1588 <xTaskResumeAll+0xe8>)
    1530:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    1532:	4b0e      	ldr	r3, [pc, #56]	; (156c <xTaskResumeAll+0xcc>)
    1534:	6fdc      	ldr	r4, [r3, #124]	; 0x7c
					if( uxPendedCounts > ( UBaseType_t ) 0U )
    1536:	2c00      	cmp	r4, #0
    1538:	d00e      	beq.n	1558 <xTaskResumeAll+0xb8>
							if( xTaskIncrementTick() != pdFALSE )
    153a:	4f14      	ldr	r7, [pc, #80]	; (158c <xTaskResumeAll+0xec>)
								xYieldPending = pdTRUE;
    153c:	4e11      	ldr	r6, [pc, #68]	; (1584 <xTaskResumeAll+0xe4>)
    153e:	2501      	movs	r5, #1
    1540:	e002      	b.n	1548 <xTaskResumeAll+0xa8>
							--uxPendedCounts;
    1542:	3c01      	subs	r4, #1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    1544:	2c00      	cmp	r4, #0
    1546:	d004      	beq.n	1552 <xTaskResumeAll+0xb2>
							if( xTaskIncrementTick() != pdFALSE )
    1548:	47b8      	blx	r7
    154a:	2800      	cmp	r0, #0
    154c:	d0f9      	beq.n	1542 <xTaskResumeAll+0xa2>
								xYieldPending = pdTRUE;
    154e:	6035      	str	r5, [r6, #0]
    1550:	e7f7      	b.n	1542 <xTaskResumeAll+0xa2>
						uxPendedTicks = 0;
    1552:	2200      	movs	r2, #0
    1554:	4b05      	ldr	r3, [pc, #20]	; (156c <xTaskResumeAll+0xcc>)
    1556:	67da      	str	r2, [r3, #124]	; 0x7c
				if( xYieldPending != pdFALSE )
    1558:	4b0a      	ldr	r3, [pc, #40]	; (1584 <xTaskResumeAll+0xe4>)
    155a:	681b      	ldr	r3, [r3, #0]
BaseType_t xAlreadyYielded = pdFALSE;
    155c:	2400      	movs	r4, #0
				if( xYieldPending != pdFALSE )
    155e:	2b00      	cmp	r3, #0
    1560:	d0b5      	beq.n	14ce <xTaskResumeAll+0x2e>
					taskYIELD_IF_USING_PREEMPTION();
    1562:	4b0b      	ldr	r3, [pc, #44]	; (1590 <xTaskResumeAll+0xf0>)
    1564:	4798      	blx	r3
						xAlreadyYielded = pdTRUE;
    1566:	3401      	adds	r4, #1
    1568:	e7b1      	b.n	14ce <xTaskResumeAll+0x2e>
    156a:	46c0      	nop			; (mov r8, r8)
    156c:	20004398 	.word	0x20004398
    1570:	00000891 	.word	0x00000891
    1574:	20004318 	.word	0x20004318
    1578:	000008a9 	.word	0x000008a9
    157c:	00000383 	.word	0x00000383
    1580:	0000033d 	.word	0x0000033d
    1584:	20004418 	.word	0x20004418
    1588:	00001035 	.word	0x00001035
    158c:	00001391 	.word	0x00001391
    1590:	00000879 	.word	0x00000879

00001594 <vTaskDelay>:
	{
    1594:	b510      	push	{r4, lr}
    1596:	1e04      	subs	r4, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
    1598:	d00f      	beq.n	15ba <vTaskDelay+0x26>
			configASSERT( uxSchedulerSuspended == 0 );
    159a:	4b09      	ldr	r3, [pc, #36]	; (15c0 <vTaskDelay+0x2c>)
    159c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    159e:	2b00      	cmp	r3, #0
    15a0:	d001      	beq.n	15a6 <vTaskDelay+0x12>
    15a2:	b672      	cpsid	i
    15a4:	e7fe      	b.n	15a4 <vTaskDelay+0x10>
			vTaskSuspendAll();
    15a6:	4b07      	ldr	r3, [pc, #28]	; (15c4 <vTaskDelay+0x30>)
    15a8:	4798      	blx	r3
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    15aa:	2100      	movs	r1, #0
    15ac:	0020      	movs	r0, r4
    15ae:	4b06      	ldr	r3, [pc, #24]	; (15c8 <vTaskDelay+0x34>)
    15b0:	4798      	blx	r3
			xAlreadyYielded = xTaskResumeAll();
    15b2:	4b06      	ldr	r3, [pc, #24]	; (15cc <vTaskDelay+0x38>)
    15b4:	4798      	blx	r3
		if( xAlreadyYielded == pdFALSE )
    15b6:	2800      	cmp	r0, #0
    15b8:	d101      	bne.n	15be <vTaskDelay+0x2a>
			portYIELD_WITHIN_API();
    15ba:	4b05      	ldr	r3, [pc, #20]	; (15d0 <vTaskDelay+0x3c>)
    15bc:	4798      	blx	r3
	}
    15be:	bd10      	pop	{r4, pc}
    15c0:	20004398 	.word	0x20004398
    15c4:	00001375 	.word	0x00001375
    15c8:	000010c9 	.word	0x000010c9
    15cc:	000014a1 	.word	0x000014a1
    15d0:	00000879 	.word	0x00000879

000015d4 <vTaskSwitchContext>:
{
    15d4:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    15d6:	4b21      	ldr	r3, [pc, #132]	; (165c <vTaskSwitchContext+0x88>)
    15d8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    15da:	2b00      	cmp	r3, #0
    15dc:	d11a      	bne.n	1614 <vTaskSwitchContext+0x40>
		xYieldPending = pdFALSE;
    15de:	2200      	movs	r2, #0
    15e0:	4b1f      	ldr	r3, [pc, #124]	; (1660 <vTaskSwitchContext+0x8c>)
    15e2:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
    15e4:	4b1d      	ldr	r3, [pc, #116]	; (165c <vTaskSwitchContext+0x88>)
    15e6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    15e8:	009a      	lsls	r2, r3, #2
    15ea:	18d2      	adds	r2, r2, r3
    15ec:	0092      	lsls	r2, r2, #2
    15ee:	491d      	ldr	r1, [pc, #116]	; (1664 <vTaskSwitchContext+0x90>)
    15f0:	188a      	adds	r2, r1, r2
    15f2:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    15f4:	2a00      	cmp	r2, #0
    15f6:	d111      	bne.n	161c <vTaskSwitchContext+0x48>
    15f8:	2b00      	cmp	r3, #0
    15fa:	d009      	beq.n	1610 <vTaskSwitchContext+0x3c>
    15fc:	3b01      	subs	r3, #1
    15fe:	009a      	lsls	r2, r3, #2
    1600:	18d2      	adds	r2, r2, r3
    1602:	0092      	lsls	r2, r2, #2
    1604:	188a      	adds	r2, r1, r2
    1606:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    1608:	2a00      	cmp	r2, #0
    160a:	d107      	bne.n	161c <vTaskSwitchContext+0x48>
    160c:	2b00      	cmp	r3, #0
    160e:	d1f5      	bne.n	15fc <vTaskSwitchContext+0x28>
    1610:	b672      	cpsid	i
    1612:	e7fe      	b.n	1612 <vTaskSwitchContext+0x3e>
		xYieldPending = pdTRUE;
    1614:	2201      	movs	r2, #1
    1616:	4b12      	ldr	r3, [pc, #72]	; (1660 <vTaskSwitchContext+0x8c>)
    1618:	601a      	str	r2, [r3, #0]
}
    161a:	bd10      	pop	{r4, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK();
    161c:	4a11      	ldr	r2, [pc, #68]	; (1664 <vTaskSwitchContext+0x90>)
    161e:	0099      	lsls	r1, r3, #2
    1620:	18c8      	adds	r0, r1, r3
    1622:	0080      	lsls	r0, r0, #2
    1624:	1810      	adds	r0, r2, r0
    1626:	6d04      	ldr	r4, [r0, #80]	; 0x50
    1628:	6864      	ldr	r4, [r4, #4]
    162a:	6504      	str	r4, [r0, #80]	; 0x50
    162c:	18c9      	adds	r1, r1, r3
    162e:	0089      	lsls	r1, r1, #2
    1630:	0002      	movs	r2, r0
    1632:	3254      	adds	r2, #84	; 0x54
    1634:	4294      	cmp	r4, r2
    1636:	d00a      	beq.n	164e <vTaskSwitchContext+0x7a>
    1638:	009a      	lsls	r2, r3, #2
    163a:	18d2      	adds	r2, r2, r3
    163c:	0092      	lsls	r2, r2, #2
    163e:	4909      	ldr	r1, [pc, #36]	; (1664 <vTaskSwitchContext+0x90>)
    1640:	188a      	adds	r2, r1, r2
    1642:	6d12      	ldr	r2, [r2, #80]	; 0x50
    1644:	68d1      	ldr	r1, [r2, #12]
    1646:	4a05      	ldr	r2, [pc, #20]	; (165c <vTaskSwitchContext+0x88>)
    1648:	6351      	str	r1, [r2, #52]	; 0x34
    164a:	66d3      	str	r3, [r2, #108]	; 0x6c
}
    164c:	e7e5      	b.n	161a <vTaskSwitchContext+0x46>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    164e:	6860      	ldr	r0, [r4, #4]
    1650:	000a      	movs	r2, r1
    1652:	4904      	ldr	r1, [pc, #16]	; (1664 <vTaskSwitchContext+0x90>)
    1654:	188a      	adds	r2, r1, r2
    1656:	6510      	str	r0, [r2, #80]	; 0x50
    1658:	e7ee      	b.n	1638 <vTaskSwitchContext+0x64>
    165a:	46c0      	nop			; (mov r8, r8)
    165c:	20004398 	.word	0x20004398
    1660:	20004418 	.word	0x20004418
    1664:	20004318 	.word	0x20004318

00001668 <vTaskPlaceOnEventList>:
{
    1668:	b510      	push	{r4, lr}
    166a:	000c      	movs	r4, r1
	configASSERT( pxEventList );
    166c:	2800      	cmp	r0, #0
    166e:	d101      	bne.n	1674 <vTaskPlaceOnEventList+0xc>
    1670:	b672      	cpsid	i
    1672:	e7fe      	b.n	1672 <vTaskPlaceOnEventList+0xa>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1674:	4b04      	ldr	r3, [pc, #16]	; (1688 <vTaskPlaceOnEventList+0x20>)
    1676:	6b59      	ldr	r1, [r3, #52]	; 0x34
    1678:	3118      	adds	r1, #24
    167a:	4b04      	ldr	r3, [pc, #16]	; (168c <vTaskPlaceOnEventList+0x24>)
    167c:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    167e:	2101      	movs	r1, #1
    1680:	0020      	movs	r0, r4
    1682:	4b03      	ldr	r3, [pc, #12]	; (1690 <vTaskPlaceOnEventList+0x28>)
    1684:	4798      	blx	r3
}
    1686:	bd10      	pop	{r4, pc}
    1688:	20004398 	.word	0x20004398
    168c:	00000355 	.word	0x00000355
    1690:	000010c9 	.word	0x000010c9

00001694 <vTaskPlaceOnEventListRestricted>:
	{
    1694:	b570      	push	{r4, r5, r6, lr}
    1696:	000c      	movs	r4, r1
    1698:	0015      	movs	r5, r2
		configASSERT( pxEventList );
    169a:	2800      	cmp	r0, #0
    169c:	d00d      	beq.n	16ba <vTaskPlaceOnEventListRestricted+0x26>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    169e:	4b08      	ldr	r3, [pc, #32]	; (16c0 <vTaskPlaceOnEventListRestricted+0x2c>)
    16a0:	6b59      	ldr	r1, [r3, #52]	; 0x34
    16a2:	3118      	adds	r1, #24
    16a4:	4b07      	ldr	r3, [pc, #28]	; (16c4 <vTaskPlaceOnEventListRestricted+0x30>)
    16a6:	4798      	blx	r3
		if( xWaitIndefinitely != pdFALSE )
    16a8:	2d00      	cmp	r5, #0
    16aa:	d001      	beq.n	16b0 <vTaskPlaceOnEventListRestricted+0x1c>
			xTicksToWait = portMAX_DELAY;
    16ac:	2401      	movs	r4, #1
    16ae:	4264      	negs	r4, r4
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    16b0:	0029      	movs	r1, r5
    16b2:	0020      	movs	r0, r4
    16b4:	4b04      	ldr	r3, [pc, #16]	; (16c8 <vTaskPlaceOnEventListRestricted+0x34>)
    16b6:	4798      	blx	r3
	}
    16b8:	bd70      	pop	{r4, r5, r6, pc}
		configASSERT( pxEventList );
    16ba:	b672      	cpsid	i
    16bc:	e7fe      	b.n	16bc <vTaskPlaceOnEventListRestricted+0x28>
    16be:	46c0      	nop			; (mov r8, r8)
    16c0:	20004398 	.word	0x20004398
    16c4:	0000033d 	.word	0x0000033d
    16c8:	000010c9 	.word	0x000010c9

000016cc <xTaskRemoveFromEventList>:
{
    16cc:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    16ce:	68c3      	ldr	r3, [r0, #12]
    16d0:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
    16d2:	2c00      	cmp	r4, #0
    16d4:	d028      	beq.n	1728 <xTaskRemoveFromEventList+0x5c>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    16d6:	0025      	movs	r5, r4
    16d8:	3518      	adds	r5, #24
    16da:	0028      	movs	r0, r5
    16dc:	4b16      	ldr	r3, [pc, #88]	; (1738 <xTaskRemoveFromEventList+0x6c>)
    16de:	4798      	blx	r3
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    16e0:	4b16      	ldr	r3, [pc, #88]	; (173c <xTaskRemoveFromEventList+0x70>)
    16e2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    16e4:	2b00      	cmp	r3, #0
    16e6:	d121      	bne.n	172c <xTaskRemoveFromEventList+0x60>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    16e8:	1d25      	adds	r5, r4, #4
    16ea:	0028      	movs	r0, r5
    16ec:	4b12      	ldr	r3, [pc, #72]	; (1738 <xTaskRemoveFromEventList+0x6c>)
    16ee:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
    16f0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    16f2:	4a12      	ldr	r2, [pc, #72]	; (173c <xTaskRemoveFromEventList+0x70>)
    16f4:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
    16f6:	4293      	cmp	r3, r2
    16f8:	d901      	bls.n	16fe <xTaskRemoveFromEventList+0x32>
    16fa:	4a10      	ldr	r2, [pc, #64]	; (173c <xTaskRemoveFromEventList+0x70>)
    16fc:	66d3      	str	r3, [r2, #108]	; 0x6c
    16fe:	0098      	lsls	r0, r3, #2
    1700:	18c3      	adds	r3, r0, r3
    1702:	009b      	lsls	r3, r3, #2
    1704:	480e      	ldr	r0, [pc, #56]	; (1740 <xTaskRemoveFromEventList+0x74>)
    1706:	304c      	adds	r0, #76	; 0x4c
    1708:	18c0      	adds	r0, r0, r3
    170a:	0029      	movs	r1, r5
    170c:	4b0d      	ldr	r3, [pc, #52]	; (1744 <xTaskRemoveFromEventList+0x78>)
    170e:	4798      	blx	r3
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1710:	4b0a      	ldr	r3, [pc, #40]	; (173c <xTaskRemoveFromEventList+0x70>)
    1712:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1714:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1716:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		xReturn = pdFALSE;
    1718:	2000      	movs	r0, #0
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    171a:	429a      	cmp	r2, r3
    171c:	d903      	bls.n	1726 <xTaskRemoveFromEventList+0x5a>
		xYieldPending = pdTRUE;
    171e:	2201      	movs	r2, #1
    1720:	4b09      	ldr	r3, [pc, #36]	; (1748 <xTaskRemoveFromEventList+0x7c>)
    1722:	601a      	str	r2, [r3, #0]
		xReturn = pdTRUE;
    1724:	3001      	adds	r0, #1
}
    1726:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxUnblockedTCB );
    1728:	b672      	cpsid	i
    172a:	e7fe      	b.n	172a <xTaskRemoveFromEventList+0x5e>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    172c:	0029      	movs	r1, r5
    172e:	4804      	ldr	r0, [pc, #16]	; (1740 <xTaskRemoveFromEventList+0x74>)
    1730:	3014      	adds	r0, #20
    1732:	4b04      	ldr	r3, [pc, #16]	; (1744 <xTaskRemoveFromEventList+0x78>)
    1734:	4798      	blx	r3
    1736:	e7eb      	b.n	1710 <xTaskRemoveFromEventList+0x44>
    1738:	00000383 	.word	0x00000383
    173c:	20004398 	.word	0x20004398
    1740:	20004318 	.word	0x20004318
    1744:	0000033d 	.word	0x0000033d
    1748:	20004418 	.word	0x20004418

0000174c <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    174c:	4b02      	ldr	r3, [pc, #8]	; (1758 <vTaskInternalSetTimeOutState+0xc>)
    174e:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    1750:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    1752:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    1754:	6043      	str	r3, [r0, #4]
}
    1756:	4770      	bx	lr
    1758:	20004398 	.word	0x20004398

0000175c <xTaskCheckForTimeOut>:
{
    175c:	b570      	push	{r4, r5, r6, lr}
    175e:	0006      	movs	r6, r0
    1760:	000d      	movs	r5, r1
	configASSERT( pxTimeOut );
    1762:	2800      	cmp	r0, #0
    1764:	d01b      	beq.n	179e <xTaskCheckForTimeOut+0x42>
	configASSERT( pxTicksToWait );
    1766:	2900      	cmp	r1, #0
    1768:	d01b      	beq.n	17a2 <xTaskCheckForTimeOut+0x46>
	taskENTER_CRITICAL();
    176a:	4b13      	ldr	r3, [pc, #76]	; (17b8 <xTaskCheckForTimeOut+0x5c>)
    176c:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
    176e:	4b13      	ldr	r3, [pc, #76]	; (17bc <xTaskCheckForTimeOut+0x60>)
    1770:	6b1a      	ldr	r2, [r3, #48]	; 0x30
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1772:	6871      	ldr	r1, [r6, #4]
			if( *pxTicksToWait == portMAX_DELAY )
    1774:	682b      	ldr	r3, [r5, #0]
    1776:	1c58      	adds	r0, r3, #1
    1778:	d01c      	beq.n	17b4 <xTaskCheckForTimeOut+0x58>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    177a:	4810      	ldr	r0, [pc, #64]	; (17bc <xTaskCheckForTimeOut+0x60>)
    177c:	6f80      	ldr	r0, [r0, #120]	; 0x78
    177e:	6834      	ldr	r4, [r6, #0]
    1780:	4284      	cmp	r4, r0
    1782:	d002      	beq.n	178a <xTaskCheckForTimeOut+0x2e>
			xReturn = pdTRUE;
    1784:	2401      	movs	r4, #1
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1786:	428a      	cmp	r2, r1
    1788:	d205      	bcs.n	1796 <xTaskCheckForTimeOut+0x3a>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    178a:	1a52      	subs	r2, r2, r1
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    178c:	429a      	cmp	r2, r3
    178e:	d30a      	bcc.n	17a6 <xTaskCheckForTimeOut+0x4a>
			*pxTicksToWait = 0;
    1790:	2300      	movs	r3, #0
    1792:	602b      	str	r3, [r5, #0]
			xReturn = pdTRUE;
    1794:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
    1796:	4b0a      	ldr	r3, [pc, #40]	; (17c0 <xTaskCheckForTimeOut+0x64>)
    1798:	4798      	blx	r3
}
    179a:	0020      	movs	r0, r4
    179c:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxTimeOut );
    179e:	b672      	cpsid	i
    17a0:	e7fe      	b.n	17a0 <xTaskCheckForTimeOut+0x44>
	configASSERT( pxTicksToWait );
    17a2:	b672      	cpsid	i
    17a4:	e7fe      	b.n	17a4 <xTaskCheckForTimeOut+0x48>
			*pxTicksToWait -= xElapsedTime;
    17a6:	1a9b      	subs	r3, r3, r2
    17a8:	602b      	str	r3, [r5, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
    17aa:	0030      	movs	r0, r6
    17ac:	4b05      	ldr	r3, [pc, #20]	; (17c4 <xTaskCheckForTimeOut+0x68>)
    17ae:	4798      	blx	r3
			xReturn = pdFALSE;
    17b0:	2400      	movs	r4, #0
    17b2:	e7f0      	b.n	1796 <xTaskCheckForTimeOut+0x3a>
				xReturn = pdFALSE;
    17b4:	2400      	movs	r4, #0
    17b6:	e7ee      	b.n	1796 <xTaskCheckForTimeOut+0x3a>
    17b8:	00000891 	.word	0x00000891
    17bc:	20004398 	.word	0x20004398
    17c0:	000008a9 	.word	0x000008a9
    17c4:	0000174d 	.word	0x0000174d

000017c8 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    17c8:	2201      	movs	r2, #1
    17ca:	4b01      	ldr	r3, [pc, #4]	; (17d0 <vTaskMissedYield+0x8>)
    17cc:	601a      	str	r2, [r3, #0]
}
    17ce:	4770      	bx	lr
    17d0:	20004418 	.word	0x20004418

000017d4 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
    17d4:	4b05      	ldr	r3, [pc, #20]	; (17ec <xTaskGetSchedulerState+0x18>)
    17d6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
			xReturn = taskSCHEDULER_NOT_STARTED;
    17d8:	2001      	movs	r0, #1
		if( xSchedulerRunning == pdFALSE )
    17da:	2b00      	cmp	r3, #0
    17dc:	d004      	beq.n	17e8 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    17de:	4b03      	ldr	r3, [pc, #12]	; (17ec <xTaskGetSchedulerState+0x18>)
    17e0:	6f18      	ldr	r0, [r3, #112]	; 0x70
				xReturn = taskSCHEDULER_SUSPENDED;
    17e2:	4243      	negs	r3, r0
    17e4:	4158      	adcs	r0, r3
    17e6:	0040      	lsls	r0, r0, #1
	}
    17e8:	4770      	bx	lr
    17ea:	46c0      	nop			; (mov r8, r8)
    17ec:	20004398 	.word	0x20004398

000017f0 <xTaskPriorityDisinherit>:
	{
    17f0:	b570      	push	{r4, r5, r6, lr}
    17f2:	1e04      	subs	r4, r0, #0
		if( pxMutexHolder != NULL )
    17f4:	d02d      	beq.n	1852 <xTaskPriorityDisinherit+0x62>
			configASSERT( pxTCB == pxCurrentTCB );
    17f6:	4b19      	ldr	r3, [pc, #100]	; (185c <xTaskPriorityDisinherit+0x6c>)
    17f8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    17fa:	4298      	cmp	r0, r3
    17fc:	d001      	beq.n	1802 <xTaskPriorityDisinherit+0x12>
    17fe:	b672      	cpsid	i
    1800:	e7fe      	b.n	1800 <xTaskPriorityDisinherit+0x10>
			configASSERT( pxTCB->uxMutexesHeld );
    1802:	6c83      	ldr	r3, [r0, #72]	; 0x48
    1804:	2b00      	cmp	r3, #0
    1806:	d101      	bne.n	180c <xTaskPriorityDisinherit+0x1c>
    1808:	b672      	cpsid	i
    180a:	e7fe      	b.n	180a <xTaskPriorityDisinherit+0x1a>
			( pxTCB->uxMutexesHeld )--;
    180c:	3b01      	subs	r3, #1
    180e:	6483      	str	r3, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1810:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    1812:	6c41      	ldr	r1, [r0, #68]	; 0x44
    1814:	428a      	cmp	r2, r1
    1816:	d01e      	beq.n	1856 <xTaskPriorityDisinherit+0x66>
	BaseType_t xReturn = pdFALSE;
    1818:	2000      	movs	r0, #0
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    181a:	2b00      	cmp	r3, #0
    181c:	d118      	bne.n	1850 <xTaskPriorityDisinherit+0x60>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    181e:	1d25      	adds	r5, r4, #4
    1820:	0028      	movs	r0, r5
    1822:	4b0f      	ldr	r3, [pc, #60]	; (1860 <xTaskPriorityDisinherit+0x70>)
    1824:	4798      	blx	r3
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    1826:	6c63      	ldr	r3, [r4, #68]	; 0x44
    1828:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    182a:	2205      	movs	r2, #5
    182c:	1ad2      	subs	r2, r2, r3
    182e:	61a2      	str	r2, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
    1830:	4a0a      	ldr	r2, [pc, #40]	; (185c <xTaskPriorityDisinherit+0x6c>)
    1832:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
    1834:	4293      	cmp	r3, r2
    1836:	d901      	bls.n	183c <xTaskPriorityDisinherit+0x4c>
    1838:	4a08      	ldr	r2, [pc, #32]	; (185c <xTaskPriorityDisinherit+0x6c>)
    183a:	66d3      	str	r3, [r2, #108]	; 0x6c
    183c:	0098      	lsls	r0, r3, #2
    183e:	18c3      	adds	r3, r0, r3
    1840:	009b      	lsls	r3, r3, #2
    1842:	4808      	ldr	r0, [pc, #32]	; (1864 <xTaskPriorityDisinherit+0x74>)
    1844:	304c      	adds	r0, #76	; 0x4c
    1846:	18c0      	adds	r0, r0, r3
    1848:	0029      	movs	r1, r5
    184a:	4b07      	ldr	r3, [pc, #28]	; (1868 <xTaskPriorityDisinherit+0x78>)
    184c:	4798      	blx	r3
					xReturn = pdTRUE;
    184e:	2001      	movs	r0, #1
	}
    1850:	bd70      	pop	{r4, r5, r6, pc}
	BaseType_t xReturn = pdFALSE;
    1852:	2000      	movs	r0, #0
    1854:	e7fc      	b.n	1850 <xTaskPriorityDisinherit+0x60>
    1856:	2000      	movs	r0, #0
    1858:	e7fa      	b.n	1850 <xTaskPriorityDisinherit+0x60>
    185a:	46c0      	nop			; (mov r8, r8)
    185c:	20004398 	.word	0x20004398
    1860:	00000383 	.word	0x00000383
    1864:	20004318 	.word	0x20004318
    1868:	0000033d 	.word	0x0000033d

0000186c <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    186c:	b510      	push	{r4, lr}
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    186e:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1870:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
    1872:	4291      	cmp	r1, r2
    1874:	d80b      	bhi.n	188e <prvInsertTimerInActiveList+0x22>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1876:	1ad2      	subs	r2, r2, r3
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    1878:	2401      	movs	r4, #1
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    187a:	6983      	ldr	r3, [r0, #24]
    187c:	429a      	cmp	r2, r3
    187e:	d211      	bcs.n	18a4 <prvInsertTimerInActiveList+0x38>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    1880:	1d01      	adds	r1, r0, #4
    1882:	4b09      	ldr	r3, [pc, #36]	; (18a8 <prvInsertTimerInActiveList+0x3c>)
    1884:	6818      	ldr	r0, [r3, #0]
    1886:	4b09      	ldr	r3, [pc, #36]	; (18ac <prvInsertTimerInActiveList+0x40>)
    1888:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
    188a:	2400      	movs	r4, #0
    188c:	e00a      	b.n	18a4 <prvInsertTimerInActiveList+0x38>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    188e:	429a      	cmp	r2, r3
    1890:	d202      	bcs.n	1898 <prvInsertTimerInActiveList+0x2c>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    1892:	2401      	movs	r4, #1
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    1894:	4299      	cmp	r1, r3
    1896:	d205      	bcs.n	18a4 <prvInsertTimerInActiveList+0x38>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1898:	1d01      	adds	r1, r0, #4
    189a:	4b03      	ldr	r3, [pc, #12]	; (18a8 <prvInsertTimerInActiveList+0x3c>)
    189c:	6858      	ldr	r0, [r3, #4]
    189e:	4b03      	ldr	r3, [pc, #12]	; (18ac <prvInsertTimerInActiveList+0x40>)
    18a0:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
    18a2:	2400      	movs	r4, #0
		}
	}

	return xProcessTimerNow;
}
    18a4:	0020      	movs	r0, r4
    18a6:	bd10      	pop	{r4, pc}
    18a8:	2000441c 	.word	0x2000441c
    18ac:	00000355 	.word	0x00000355

000018b0 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
    18b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    18b2:	4b10      	ldr	r3, [pc, #64]	; (18f4 <prvCheckForValidListAndQueue+0x44>)
    18b4:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
    18b6:	4b10      	ldr	r3, [pc, #64]	; (18f8 <prvCheckForValidListAndQueue+0x48>)
    18b8:	689b      	ldr	r3, [r3, #8]
    18ba:	2b00      	cmp	r3, #0
    18bc:	d002      	beq.n	18c4 <prvCheckForValidListAndQueue+0x14>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    18be:	4b0f      	ldr	r3, [pc, #60]	; (18fc <prvCheckForValidListAndQueue+0x4c>)
    18c0:	4798      	blx	r3
}
    18c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInitialise( &xActiveTimerList1 );
    18c4:	4c0c      	ldr	r4, [pc, #48]	; (18f8 <prvCheckForValidListAndQueue+0x48>)
    18c6:	0026      	movs	r6, r4
    18c8:	360c      	adds	r6, #12
    18ca:	0030      	movs	r0, r6
    18cc:	4f0c      	ldr	r7, [pc, #48]	; (1900 <prvCheckForValidListAndQueue+0x50>)
    18ce:	47b8      	blx	r7
			vListInitialise( &xActiveTimerList2 );
    18d0:	0025      	movs	r5, r4
    18d2:	3520      	adds	r5, #32
    18d4:	0028      	movs	r0, r5
    18d6:	47b8      	blx	r7
			pxCurrentTimerList = &xActiveTimerList1;
    18d8:	6066      	str	r6, [r4, #4]
			pxOverflowTimerList = &xActiveTimerList2;
    18da:	6025      	str	r5, [r4, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    18dc:	2200      	movs	r2, #0
    18de:	210c      	movs	r1, #12
    18e0:	2005      	movs	r0, #5
    18e2:	4b08      	ldr	r3, [pc, #32]	; (1904 <prvCheckForValidListAndQueue+0x54>)
    18e4:	4798      	blx	r3
    18e6:	60a0      	str	r0, [r4, #8]
				if( xTimerQueue != NULL )
    18e8:	2800      	cmp	r0, #0
    18ea:	d0e8      	beq.n	18be <prvCheckForValidListAndQueue+0xe>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
    18ec:	4906      	ldr	r1, [pc, #24]	; (1908 <prvCheckForValidListAndQueue+0x58>)
    18ee:	4b07      	ldr	r3, [pc, #28]	; (190c <prvCheckForValidListAndQueue+0x5c>)
    18f0:	4798      	blx	r3
    18f2:	e7e4      	b.n	18be <prvCheckForValidListAndQueue+0xe>
    18f4:	00000891 	.word	0x00000891
    18f8:	2000441c 	.word	0x2000441c
    18fc:	000008a9 	.word	0x000008a9
    1900:	00000321 	.word	0x00000321
    1904:	00000ba9 	.word	0x00000ba9
    1908:	00002020 	.word	0x00002020
    190c:	00000fa5 	.word	0x00000fa5

00001910 <xTimerCreateTimerTask>:
{
    1910:	b510      	push	{r4, lr}
    1912:	b082      	sub	sp, #8
	prvCheckForValidListAndQueue();
    1914:	4b0b      	ldr	r3, [pc, #44]	; (1944 <xTimerCreateTimerTask+0x34>)
    1916:	4798      	blx	r3
	if( xTimerQueue != NULL )
    1918:	4b0b      	ldr	r3, [pc, #44]	; (1948 <xTimerCreateTimerTask+0x38>)
    191a:	689b      	ldr	r3, [r3, #8]
    191c:	2b00      	cmp	r3, #0
    191e:	d00e      	beq.n	193e <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate(	prvTimerTask,
    1920:	4b09      	ldr	r3, [pc, #36]	; (1948 <xTimerCreateTimerTask+0x38>)
    1922:	3334      	adds	r3, #52	; 0x34
    1924:	9301      	str	r3, [sp, #4]
    1926:	2302      	movs	r3, #2
    1928:	9300      	str	r3, [sp, #0]
    192a:	2300      	movs	r3, #0
    192c:	2250      	movs	r2, #80	; 0x50
    192e:	4907      	ldr	r1, [pc, #28]	; (194c <xTimerCreateTimerTask+0x3c>)
    1930:	4807      	ldr	r0, [pc, #28]	; (1950 <xTimerCreateTimerTask+0x40>)
    1932:	4c08      	ldr	r4, [pc, #32]	; (1954 <xTimerCreateTimerTask+0x44>)
    1934:	47a0      	blx	r4
	configASSERT( xReturn );
    1936:	2800      	cmp	r0, #0
    1938:	d001      	beq.n	193e <xTimerCreateTimerTask+0x2e>
}
    193a:	b002      	add	sp, #8
    193c:	bd10      	pop	{r4, pc}
	configASSERT( xReturn );
    193e:	b672      	cpsid	i
    1940:	e7fe      	b.n	1940 <xTimerCreateTimerTask+0x30>
    1942:	46c0      	nop			; (mov r8, r8)
    1944:	000018b1 	.word	0x000018b1
    1948:	2000441c 	.word	0x2000441c
    194c:	00002028 	.word	0x00002028
    1950:	00001a75 	.word	0x00001a75
    1954:	00001139 	.word	0x00001139

00001958 <xTimerGenericCommand>:
{
    1958:	b530      	push	{r4, r5, lr}
    195a:	b085      	sub	sp, #20
    195c:	0004      	movs	r4, r0
    195e:	001d      	movs	r5, r3
	configASSERT( xTimer );
    1960:	2800      	cmp	r0, #0
    1962:	d014      	beq.n	198e <xTimerGenericCommand+0x36>
	if( xTimerQueue != NULL )
    1964:	4b13      	ldr	r3, [pc, #76]	; (19b4 <xTimerGenericCommand+0x5c>)
    1966:	6898      	ldr	r0, [r3, #8]
    1968:	2800      	cmp	r0, #0
    196a:	d021      	beq.n	19b0 <xTimerGenericCommand+0x58>
		xMessage.xMessageID = xCommandID;
    196c:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    196e:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    1970:	9403      	str	r4, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    1972:	2905      	cmp	r1, #5
    1974:	dc15      	bgt.n	19a2 <xTimerGenericCommand+0x4a>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1976:	4b10      	ldr	r3, [pc, #64]	; (19b8 <xTimerGenericCommand+0x60>)
    1978:	4798      	blx	r3
    197a:	2802      	cmp	r0, #2
    197c:	d009      	beq.n	1992 <xTimerGenericCommand+0x3a>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    197e:	4b0d      	ldr	r3, [pc, #52]	; (19b4 <xTimerGenericCommand+0x5c>)
    1980:	6898      	ldr	r0, [r3, #8]
    1982:	2300      	movs	r3, #0
    1984:	2200      	movs	r2, #0
    1986:	a901      	add	r1, sp, #4
    1988:	4c0c      	ldr	r4, [pc, #48]	; (19bc <xTimerGenericCommand+0x64>)
    198a:	47a0      	blx	r4
    198c:	e00e      	b.n	19ac <xTimerGenericCommand+0x54>
	configASSERT( xTimer );
    198e:	b672      	cpsid	i
    1990:	e7fe      	b.n	1990 <xTimerGenericCommand+0x38>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    1992:	4b08      	ldr	r3, [pc, #32]	; (19b4 <xTimerGenericCommand+0x5c>)
    1994:	6898      	ldr	r0, [r3, #8]
    1996:	2300      	movs	r3, #0
    1998:	9a08      	ldr	r2, [sp, #32]
    199a:	a901      	add	r1, sp, #4
    199c:	4c07      	ldr	r4, [pc, #28]	; (19bc <xTimerGenericCommand+0x64>)
    199e:	47a0      	blx	r4
    19a0:	e004      	b.n	19ac <xTimerGenericCommand+0x54>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    19a2:	2300      	movs	r3, #0
    19a4:	002a      	movs	r2, r5
    19a6:	a901      	add	r1, sp, #4
    19a8:	4c05      	ldr	r4, [pc, #20]	; (19c0 <xTimerGenericCommand+0x68>)
    19aa:	47a0      	blx	r4
}
    19ac:	b005      	add	sp, #20
    19ae:	bd30      	pop	{r4, r5, pc}
BaseType_t xReturn = pdFAIL;
    19b0:	2000      	movs	r0, #0
	return xReturn;
    19b2:	e7fb      	b.n	19ac <xTimerGenericCommand+0x54>
    19b4:	2000441c 	.word	0x2000441c
    19b8:	000017d5 	.word	0x000017d5
    19bc:	00000bf5 	.word	0x00000bf5
    19c0:	00000d81 	.word	0x00000d81

000019c4 <prvSampleTimeNow>:
{
    19c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    19c6:	46d6      	mov	lr, sl
    19c8:	464f      	mov	r7, r9
    19ca:	4646      	mov	r6, r8
    19cc:	b5c0      	push	{r6, r7, lr}
    19ce:	b082      	sub	sp, #8
    19d0:	4680      	mov	r8, r0
	xTimeNow = xTaskGetTickCount();
    19d2:	4b23      	ldr	r3, [pc, #140]	; (1a60 <prvSampleTimeNow+0x9c>)
    19d4:	4798      	blx	r3
    19d6:	4682      	mov	sl, r0
	if( xTimeNow < xLastTime )
    19d8:	4b22      	ldr	r3, [pc, #136]	; (1a64 <prvSampleTimeNow+0xa0>)
    19da:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    19dc:	4298      	cmp	r0, r3
    19de:	d317      	bcc.n	1a10 <prvSampleTimeNow+0x4c>
		*pxTimerListsWereSwitched = pdFALSE;
    19e0:	2300      	movs	r3, #0
    19e2:	4642      	mov	r2, r8
    19e4:	6013      	str	r3, [r2, #0]
	xLastTime = xTimeNow;
    19e6:	4b1f      	ldr	r3, [pc, #124]	; (1a64 <prvSampleTimeNow+0xa0>)
    19e8:	4652      	mov	r2, sl
    19ea:	639a      	str	r2, [r3, #56]	; 0x38
}
    19ec:	4650      	mov	r0, sl
    19ee:	b002      	add	sp, #8
    19f0:	bc1c      	pop	{r2, r3, r4}
    19f2:	4690      	mov	r8, r2
    19f4:	4699      	mov	r9, r3
    19f6:	46a2      	mov	sl, r4
    19f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    19fa:	2300      	movs	r3, #0
    19fc:	9300      	str	r3, [sp, #0]
    19fe:	003a      	movs	r2, r7
    1a00:	2100      	movs	r1, #0
    1a02:	0020      	movs	r0, r4
    1a04:	4c18      	ldr	r4, [pc, #96]	; (1a68 <prvSampleTimeNow+0xa4>)
    1a06:	47a0      	blx	r4
				configASSERT( xResult );
    1a08:	2800      	cmp	r0, #0
    1a0a:	d104      	bne.n	1a16 <prvSampleTimeNow+0x52>
    1a0c:	b672      	cpsid	i
    1a0e:	e7fe      	b.n	1a0e <prvSampleTimeNow+0x4a>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1a10:	4d14      	ldr	r5, [pc, #80]	; (1a64 <prvSampleTimeNow+0xa0>)
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1a12:	4b16      	ldr	r3, [pc, #88]	; (1a6c <prvSampleTimeNow+0xa8>)
    1a14:	4699      	mov	r9, r3
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1a16:	686b      	ldr	r3, [r5, #4]
    1a18:	681a      	ldr	r2, [r3, #0]
    1a1a:	2a00      	cmp	r2, #0
    1a1c:	d017      	beq.n	1a4e <prvSampleTimeNow+0x8a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1a1e:	68db      	ldr	r3, [r3, #12]
    1a20:	681f      	ldr	r7, [r3, #0]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1a22:	68dc      	ldr	r4, [r3, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1a24:	1d26      	adds	r6, r4, #4
    1a26:	0030      	movs	r0, r6
    1a28:	47c8      	blx	r9
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1a2a:	0020      	movs	r0, r4
    1a2c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1a2e:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1a30:	69e3      	ldr	r3, [r4, #28]
    1a32:	2b01      	cmp	r3, #1
    1a34:	d1ef      	bne.n	1a16 <prvSampleTimeNow+0x52>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1a36:	69a3      	ldr	r3, [r4, #24]
    1a38:	18fb      	adds	r3, r7, r3
			if( xReloadTime > xNextExpireTime )
    1a3a:	429f      	cmp	r7, r3
    1a3c:	d2dd      	bcs.n	19fa <prvSampleTimeNow+0x36>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1a3e:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1a40:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1a42:	4b08      	ldr	r3, [pc, #32]	; (1a64 <prvSampleTimeNow+0xa0>)
    1a44:	6858      	ldr	r0, [r3, #4]
    1a46:	0031      	movs	r1, r6
    1a48:	4b09      	ldr	r3, [pc, #36]	; (1a70 <prvSampleTimeNow+0xac>)
    1a4a:	4798      	blx	r3
    1a4c:	e7e3      	b.n	1a16 <prvSampleTimeNow+0x52>
	pxCurrentTimerList = pxOverflowTimerList;
    1a4e:	4a05      	ldr	r2, [pc, #20]	; (1a64 <prvSampleTimeNow+0xa0>)
    1a50:	6811      	ldr	r1, [r2, #0]
    1a52:	6051      	str	r1, [r2, #4]
	pxOverflowTimerList = pxTemp;
    1a54:	6013      	str	r3, [r2, #0]
		*pxTimerListsWereSwitched = pdTRUE;
    1a56:	2301      	movs	r3, #1
    1a58:	4642      	mov	r2, r8
    1a5a:	6013      	str	r3, [r2, #0]
    1a5c:	e7c3      	b.n	19e6 <prvSampleTimeNow+0x22>
    1a5e:	46c0      	nop			; (mov r8, r8)
    1a60:	00001385 	.word	0x00001385
    1a64:	2000441c 	.word	0x2000441c
    1a68:	00001959 	.word	0x00001959
    1a6c:	00000383 	.word	0x00000383
    1a70:	00000355 	.word	0x00000355

00001a74 <prvTimerTask>:
{
    1a74:	b5f0      	push	{r4, r5, r6, r7, lr}
    1a76:	b089      	sub	sp, #36	; 0x24
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1a78:	4f52      	ldr	r7, [pc, #328]	; (1bc4 <prvTimerTask+0x150>)
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    1a7a:	4b53      	ldr	r3, [pc, #332]	; (1bc8 <prvTimerTask+0x154>)
    1a7c:	685b      	ldr	r3, [r3, #4]
    1a7e:	681a      	ldr	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
    1a80:	2a00      	cmp	r2, #0
    1a82:	d00e      	beq.n	1aa2 <prvTimerTask+0x2e>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1a84:	68db      	ldr	r3, [r3, #12]
    1a86:	681c      	ldr	r4, [r3, #0]
	vTaskSuspendAll();
    1a88:	4b50      	ldr	r3, [pc, #320]	; (1bcc <prvTimerTask+0x158>)
    1a8a:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1a8c:	a805      	add	r0, sp, #20
    1a8e:	4b50      	ldr	r3, [pc, #320]	; (1bd0 <prvTimerTask+0x15c>)
    1a90:	4798      	blx	r3
    1a92:	0005      	movs	r5, r0
		if( xTimerListsWereSwitched == pdFALSE )
    1a94:	9b05      	ldr	r3, [sp, #20]
    1a96:	2b00      	cmp	r3, #0
    1a98:	d15f      	bne.n	1b5a <prvTimerTask+0xe6>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1a9a:	42a0      	cmp	r0, r4
    1a9c:	d236      	bcs.n	1b0c <prvTimerTask+0x98>
    1a9e:	2200      	movs	r2, #0
    1aa0:	e00f      	b.n	1ac2 <prvTimerTask+0x4e>
	vTaskSuspendAll();
    1aa2:	4b4a      	ldr	r3, [pc, #296]	; (1bcc <prvTimerTask+0x158>)
    1aa4:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1aa6:	a805      	add	r0, sp, #20
    1aa8:	4b49      	ldr	r3, [pc, #292]	; (1bd0 <prvTimerTask+0x15c>)
    1aaa:	4798      	blx	r3
    1aac:	0005      	movs	r5, r0
		if( xTimerListsWereSwitched == pdFALSE )
    1aae:	9b05      	ldr	r3, [sp, #20]
    1ab0:	2b00      	cmp	r3, #0
    1ab2:	d152      	bne.n	1b5a <prvTimerTask+0xe6>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1ab4:	4b44      	ldr	r3, [pc, #272]	; (1bc8 <prvTimerTask+0x154>)
    1ab6:	681b      	ldr	r3, [r3, #0]
    1ab8:	681b      	ldr	r3, [r3, #0]
    1aba:	425a      	negs	r2, r3
    1abc:	415a      	adcs	r2, r3
    1abe:	b2d2      	uxtb	r2, r2
    1ac0:	2400      	movs	r4, #0
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    1ac2:	1b61      	subs	r1, r4, r5
    1ac4:	4b40      	ldr	r3, [pc, #256]	; (1bc8 <prvTimerTask+0x154>)
    1ac6:	6898      	ldr	r0, [r3, #8]
    1ac8:	4b42      	ldr	r3, [pc, #264]	; (1bd4 <prvTimerTask+0x160>)
    1aca:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    1acc:	4b42      	ldr	r3, [pc, #264]	; (1bd8 <prvTimerTask+0x164>)
    1ace:	4798      	blx	r3
    1ad0:	2800      	cmp	r0, #0
    1ad2:	d03f      	beq.n	1b54 <prvTimerTask+0xe0>
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    1ad4:	4d3c      	ldr	r5, [pc, #240]	; (1bc8 <prvTimerTask+0x154>)
    1ad6:	4c41      	ldr	r4, [pc, #260]	; (1bdc <prvTimerTask+0x168>)
    1ad8:	2200      	movs	r2, #0
    1ada:	a905      	add	r1, sp, #20
    1adc:	68a8      	ldr	r0, [r5, #8]
    1ade:	47a0      	blx	r4
    1ae0:	2800      	cmp	r0, #0
    1ae2:	d0ca      	beq.n	1a7a <prvTimerTask+0x6>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    1ae4:	9b05      	ldr	r3, [sp, #20]
    1ae6:	9303      	str	r3, [sp, #12]
    1ae8:	2b00      	cmp	r3, #0
    1aea:	dbf5      	blt.n	1ad8 <prvTimerTask+0x64>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    1aec:	9e07      	ldr	r6, [sp, #28]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    1aee:	6973      	ldr	r3, [r6, #20]
    1af0:	2b00      	cmp	r3, #0
    1af2:	d001      	beq.n	1af8 <prvTimerTask+0x84>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1af4:	1d30      	adds	r0, r6, #4
    1af6:	47b8      	blx	r7
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1af8:	a804      	add	r0, sp, #16
    1afa:	4b35      	ldr	r3, [pc, #212]	; (1bd0 <prvTimerTask+0x15c>)
    1afc:	4798      	blx	r3
			switch( xMessage.xMessageID )
    1afe:	9b05      	ldr	r3, [sp, #20]
    1b00:	2b09      	cmp	r3, #9
    1b02:	d8e9      	bhi.n	1ad8 <prvTimerTask+0x64>
    1b04:	009b      	lsls	r3, r3, #2
    1b06:	4a36      	ldr	r2, [pc, #216]	; (1be0 <prvTimerTask+0x16c>)
    1b08:	58d3      	ldr	r3, [r2, r3]
    1b0a:	469f      	mov	pc, r3
				( void ) xTaskResumeAll();
    1b0c:	4b32      	ldr	r3, [pc, #200]	; (1bd8 <prvTimerTask+0x164>)
    1b0e:	4798      	blx	r3
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1b10:	4b2d      	ldr	r3, [pc, #180]	; (1bc8 <prvTimerTask+0x154>)
    1b12:	685b      	ldr	r3, [r3, #4]
    1b14:	68db      	ldr	r3, [r3, #12]
    1b16:	68de      	ldr	r6, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1b18:	1d30      	adds	r0, r6, #4
    1b1a:	4b2a      	ldr	r3, [pc, #168]	; (1bc4 <prvTimerTask+0x150>)
    1b1c:	4798      	blx	r3
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1b1e:	69f3      	ldr	r3, [r6, #28]
    1b20:	2b01      	cmp	r3, #1
    1b22:	d003      	beq.n	1b2c <prvTimerTask+0xb8>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1b24:	6a73      	ldr	r3, [r6, #36]	; 0x24
    1b26:	0030      	movs	r0, r6
    1b28:	4798      	blx	r3
    1b2a:	e7d3      	b.n	1ad4 <prvTimerTask+0x60>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    1b2c:	69b3      	ldr	r3, [r6, #24]
    1b2e:	18e1      	adds	r1, r4, r3
    1b30:	0023      	movs	r3, r4
    1b32:	002a      	movs	r2, r5
    1b34:	0030      	movs	r0, r6
    1b36:	4d2b      	ldr	r5, [pc, #172]	; (1be4 <prvTimerTask+0x170>)
    1b38:	47a8      	blx	r5
    1b3a:	2800      	cmp	r0, #0
    1b3c:	d0f2      	beq.n	1b24 <prvTimerTask+0xb0>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1b3e:	2300      	movs	r3, #0
    1b40:	9300      	str	r3, [sp, #0]
    1b42:	0022      	movs	r2, r4
    1b44:	2100      	movs	r1, #0
    1b46:	0030      	movs	r0, r6
    1b48:	4c27      	ldr	r4, [pc, #156]	; (1be8 <prvTimerTask+0x174>)
    1b4a:	47a0      	blx	r4
			configASSERT( xResult );
    1b4c:	2800      	cmp	r0, #0
    1b4e:	d1e9      	bne.n	1b24 <prvTimerTask+0xb0>
    1b50:	b672      	cpsid	i
    1b52:	e7fe      	b.n	1b52 <prvTimerTask+0xde>
					portYIELD_WITHIN_API();
    1b54:	4b25      	ldr	r3, [pc, #148]	; (1bec <prvTimerTask+0x178>)
    1b56:	4798      	blx	r3
    1b58:	e7bc      	b.n	1ad4 <prvTimerTask+0x60>
			( void ) xTaskResumeAll();
    1b5a:	4b1f      	ldr	r3, [pc, #124]	; (1bd8 <prvTimerTask+0x164>)
    1b5c:	4798      	blx	r3
    1b5e:	e7b9      	b.n	1ad4 <prvTimerTask+0x60>
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    1b60:	9b06      	ldr	r3, [sp, #24]
    1b62:	69b2      	ldr	r2, [r6, #24]
    1b64:	4694      	mov	ip, r2
    1b66:	4463      	add	r3, ip
    1b68:	0019      	movs	r1, r3
    1b6a:	9b06      	ldr	r3, [sp, #24]
    1b6c:	0002      	movs	r2, r0
    1b6e:	0030      	movs	r0, r6
    1b70:	4c1c      	ldr	r4, [pc, #112]	; (1be4 <prvTimerTask+0x170>)
    1b72:	47a0      	blx	r4
    1b74:	2800      	cmp	r0, #0
    1b76:	d0ae      	beq.n	1ad6 <prvTimerTask+0x62>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1b78:	0030      	movs	r0, r6
    1b7a:	6a73      	ldr	r3, [r6, #36]	; 0x24
    1b7c:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1b7e:	69f3      	ldr	r3, [r6, #28]
    1b80:	2b01      	cmp	r3, #1
    1b82:	d1a8      	bne.n	1ad6 <prvTimerTask+0x62>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    1b84:	9b06      	ldr	r3, [sp, #24]
    1b86:	69b1      	ldr	r1, [r6, #24]
    1b88:	468c      	mov	ip, r1
    1b8a:	4463      	add	r3, ip
    1b8c:	001a      	movs	r2, r3
    1b8e:	2300      	movs	r3, #0
    1b90:	9300      	str	r3, [sp, #0]
    1b92:	2100      	movs	r1, #0
    1b94:	0030      	movs	r0, r6
    1b96:	4c14      	ldr	r4, [pc, #80]	; (1be8 <prvTimerTask+0x174>)
    1b98:	47a0      	blx	r4
							configASSERT( xResult );
    1b9a:	2800      	cmp	r0, #0
    1b9c:	d19b      	bne.n	1ad6 <prvTimerTask+0x62>
    1b9e:	b672      	cpsid	i
    1ba0:	e7fe      	b.n	1ba0 <prvTimerTask+0x12c>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    1ba2:	9906      	ldr	r1, [sp, #24]
    1ba4:	61b1      	str	r1, [r6, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    1ba6:	2900      	cmp	r1, #0
    1ba8:	d006      	beq.n	1bb8 <prvTimerTask+0x144>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    1baa:	1841      	adds	r1, r0, r1
    1bac:	0003      	movs	r3, r0
    1bae:	0002      	movs	r2, r0
    1bb0:	0030      	movs	r0, r6
    1bb2:	4c0c      	ldr	r4, [pc, #48]	; (1be4 <prvTimerTask+0x170>)
    1bb4:	47a0      	blx	r4
    1bb6:	e78e      	b.n	1ad6 <prvTimerTask+0x62>
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    1bb8:	b672      	cpsid	i
    1bba:	e7fe      	b.n	1bba <prvTimerTask+0x146>
						vPortFree( pxTimer );
    1bbc:	0030      	movs	r0, r6
    1bbe:	4b0c      	ldr	r3, [pc, #48]	; (1bf0 <prvTimerTask+0x17c>)
    1bc0:	4798      	blx	r3
    1bc2:	e788      	b.n	1ad6 <prvTimerTask+0x62>
    1bc4:	00000383 	.word	0x00000383
    1bc8:	2000441c 	.word	0x2000441c
    1bcc:	00001375 	.word	0x00001375
    1bd0:	000019c5 	.word	0x000019c5
    1bd4:	00000fd5 	.word	0x00000fd5
    1bd8:	000014a1 	.word	0x000014a1
    1bdc:	00000e51 	.word	0x00000e51
    1be0:	00001ff8 	.word	0x00001ff8
    1be4:	0000186d 	.word	0x0000186d
    1be8:	00001959 	.word	0x00001959
    1bec:	00000879 	.word	0x00000879
    1bf0:	000002d9 	.word	0x000002d9

00001bf4 <initUART>:
/* Replace with your library code */
void initUART(void) {

	/* APBCMASK */
   /* SERCOM 0 enable*/
	PM->APBCMASK.reg |= PM_APBCMASK_SERCOM0;
    1bf4:	4a1f      	ldr	r2, [pc, #124]	; (1c74 <initUART+0x80>)
    1bf6:	6a13      	ldr	r3, [r2, #32]
    1bf8:	2104      	movs	r1, #4
    1bfa:	430b      	orrs	r3, r1
    1bfc:	6213      	str	r3, [r2, #32]

	/*GCLK configuration for sercom0 module: using generic clock generator 0, ID for sercom0, enable GCLK*/
    GCLK->GENCTRL.reg=GCLK_GENCTRL_SRC_OSC8M|GCLK_GENCTRL_ID(0)|
    1bfe:	4b1e      	ldr	r3, [pc, #120]	; (1c78 <initUART+0x84>)
    1c00:	2283      	movs	r2, #131	; 0x83
    1c02:	0252      	lsls	r2, r2, #9
    1c04:	605a      	str	r2, [r3, #4]
	GCLK_GENCTRL_GENEN;

	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM0_GCLK_ID_CORE) |
    1c06:	4a1d      	ldr	r2, [pc, #116]	; (1c7c <initUART+0x88>)
    1c08:	805a      	strh	r2, [r3, #2]
	GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN(0);

  /*CONFIGURAR PA10 y PA11 como salidas tipo C (SERCOM 0) */
  PORT->Group[0].PINCFG[PIN_PA10].reg= PA10_TX;
    1c0a:	4b1d      	ldr	r3, [pc, #116]	; (1c80 <initUART+0x8c>)
    1c0c:	3903      	subs	r1, #3
    1c0e:	224a      	movs	r2, #74	; 0x4a
    1c10:	5499      	strb	r1, [r3, r2]
  PORT->Group[0].PINCFG[PIN_PA11].reg= PA11_RX;
    1c12:	3106      	adds	r1, #6
    1c14:	3201      	adds	r2, #1
    1c16:	5499      	strb	r1, [r3, r2]
  PORT->Group[0].PMUX[5].bit.PMUXE=Type_C;
    1c18:	312e      	adds	r1, #46	; 0x2e
    1c1a:	5c5a      	ldrb	r2, [r3, r1]
    1c1c:	200f      	movs	r0, #15
    1c1e:	4382      	bics	r2, r0
    1c20:	2002      	movs	r0, #2
    1c22:	4302      	orrs	r2, r0
    1c24:	545a      	strb	r2, [r3, r1]
  PORT->Group[0].PMUX[5].bit.PMUXO=Type_C;
    1c26:	5c58      	ldrb	r0, [r3, r1]
    1c28:	220f      	movs	r2, #15
    1c2a:	4002      	ands	r2, r0
    1c2c:	2020      	movs	r0, #32
    1c2e:	4302      	orrs	r2, r0
    1c30:	545a      	strb	r2, [r3, r1]
	
	//desahibilitar UART para inicializacion
	SERCOM0->USART.CTRLA.bit.ENABLE=0;
    1c32:	4b14      	ldr	r3, [pc, #80]	; (1c84 <initUART+0x90>)
    1c34:	681a      	ldr	r2, [r3, #0]
    1c36:	3933      	subs	r1, #51	; 0x33
    1c38:	438a      	bics	r2, r1
    1c3a:	601a      	str	r2, [r3, #0]
   
   DEFINES:
   1)SERCOM_USART_CTRLA_DORD (_U(0x1) << SERCOM_USART_CTRLA_DORD_Pos)
   2)SERCOM_USART_CTRLA_MODE_USART_INT_CLK (0x1 << 2)
   3)SERCOM_USART_CTRLA_RXPO(value) (SERCOM_USART_CTRLA_RXPO_Msk & ((value) << SERCOM_USART_CTRLA_RXPO_Pos) */
	SERCOM0->USART.CTRLA.reg =
    1c3c:	4a12      	ldr	r2, [pc, #72]	; (1c88 <initUART+0x94>)
    1c3e:	601a      	str	r2, [r3, #0]
	SERCOM_USART_CTRLA_DORD | SERCOM_USART_CTRLA_MODE_USART_INT_CLK |
	SERCOM_USART_CTRLA_RXPO(3) | SERCOM_USART_CTRLA_TXPO(1);
	
	while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
    1c40:	001a      	movs	r2, r3
    1c42:	69d3      	ldr	r3, [r2, #28]
    1c44:	2b00      	cmp	r3, #0
    1c46:	d1fc      	bne.n	1c42 <initUART+0x4e>
	uint64_t br = (uint64_t)65536 * (8000000 - 16 * 9600) / 8000000;

	SERCOM0->USART.BAUD.reg = (uint16_t)br;
    1c48:	4a10      	ldr	r2, [pc, #64]	; (1c8c <initUART+0x98>)
    1c4a:	4b0e      	ldr	r3, [pc, #56]	; (1c84 <initUART+0x90>)
    1c4c:	819a      	strh	r2, [r3, #12]
	
	while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
    1c4e:	001a      	movs	r2, r3
    1c50:	69d3      	ldr	r3, [r2, #28]
    1c52:	2b00      	cmp	r3, #0
    1c54:	d1fc      	bne.n	1c50 <initUART+0x5c>
	SERCOM0->USART.CTRLB.reg = SERCOM_USART_CTRLB_RXEN | SERCOM_USART_CTRLB_TXEN | SERCOM_USART_CTRLB_CHSIZE(0/*8 bits*/);
    1c56:	22c0      	movs	r2, #192	; 0xc0
    1c58:	0292      	lsls	r2, r2, #10
    1c5a:	4b0a      	ldr	r3, [pc, #40]	; (1c84 <initUART+0x90>)
    1c5c:	605a      	str	r2, [r3, #4]
    while(SERCOM0->USART.SYNCBUSY.reg){} // waiting loading
    1c5e:	001a      	movs	r2, r3
    1c60:	69d3      	ldr	r3, [r2, #28]
    1c62:	2b00      	cmp	r3, #0
    1c64:	d1fc      	bne.n	1c60 <initUART+0x6c>
	SERCOM0->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    1c66:	4a07      	ldr	r2, [pc, #28]	; (1c84 <initUART+0x90>)
    1c68:	6813      	ldr	r3, [r2, #0]
    1c6a:	2102      	movs	r1, #2
    1c6c:	430b      	orrs	r3, r1
    1c6e:	6013      	str	r3, [r2, #0]
}
    1c70:	4770      	bx	lr
    1c72:	46c0      	nop			; (mov r8, r8)
    1c74:	40000400 	.word	0x40000400
    1c78:	40000c00 	.word	0x40000c00
    1c7c:	00004014 	.word	0x00004014
    1c80:	41004400 	.word	0x41004400
    1c84:	42000800 	.word	0x42000800
    1c88:	40310004 	.word	0x40310004
    1c8c:	fffffb15 	.word	0xfffffb15

00001c90 <__libc_init_array>:
    1c90:	b570      	push	{r4, r5, r6, lr}
    1c92:	4e0d      	ldr	r6, [pc, #52]	; (1cc8 <__libc_init_array+0x38>)
    1c94:	4d0d      	ldr	r5, [pc, #52]	; (1ccc <__libc_init_array+0x3c>)
    1c96:	2400      	movs	r4, #0
    1c98:	1bad      	subs	r5, r5, r6
    1c9a:	10ad      	asrs	r5, r5, #2
    1c9c:	d005      	beq.n	1caa <__libc_init_array+0x1a>
    1c9e:	00a3      	lsls	r3, r4, #2
    1ca0:	58f3      	ldr	r3, [r6, r3]
    1ca2:	3401      	adds	r4, #1
    1ca4:	4798      	blx	r3
    1ca6:	42a5      	cmp	r5, r4
    1ca8:	d1f9      	bne.n	1c9e <__libc_init_array+0xe>
    1caa:	f000 f9c3 	bl	2034 <_init>
    1cae:	4e08      	ldr	r6, [pc, #32]	; (1cd0 <__libc_init_array+0x40>)
    1cb0:	4d08      	ldr	r5, [pc, #32]	; (1cd4 <__libc_init_array+0x44>)
    1cb2:	2400      	movs	r4, #0
    1cb4:	1bad      	subs	r5, r5, r6
    1cb6:	10ad      	asrs	r5, r5, #2
    1cb8:	d005      	beq.n	1cc6 <__libc_init_array+0x36>
    1cba:	00a3      	lsls	r3, r4, #2
    1cbc:	58f3      	ldr	r3, [r6, r3]
    1cbe:	3401      	adds	r4, #1
    1cc0:	4798      	blx	r3
    1cc2:	42a5      	cmp	r5, r4
    1cc4:	d1f9      	bne.n	1cba <__libc_init_array+0x2a>
    1cc6:	bd70      	pop	{r4, r5, r6, pc}
    1cc8:	00002040 	.word	0x00002040
    1ccc:	00002040 	.word	0x00002040
    1cd0:	00002040 	.word	0x00002040
    1cd4:	00002048 	.word	0x00002048

00001cd8 <memcpy>:
    1cd8:	b5f0      	push	{r4, r5, r6, r7, lr}
    1cda:	0005      	movs	r5, r0
    1cdc:	2a0f      	cmp	r2, #15
    1cde:	d92f      	bls.n	1d40 <memcpy+0x68>
    1ce0:	000b      	movs	r3, r1
    1ce2:	4303      	orrs	r3, r0
    1ce4:	079b      	lsls	r3, r3, #30
    1ce6:	d134      	bne.n	1d52 <memcpy+0x7a>
    1ce8:	0016      	movs	r6, r2
    1cea:	000c      	movs	r4, r1
    1cec:	0003      	movs	r3, r0
    1cee:	3e10      	subs	r6, #16
    1cf0:	0935      	lsrs	r5, r6, #4
    1cf2:	3501      	adds	r5, #1
    1cf4:	012d      	lsls	r5, r5, #4
    1cf6:	1945      	adds	r5, r0, r5
    1cf8:	6827      	ldr	r7, [r4, #0]
    1cfa:	601f      	str	r7, [r3, #0]
    1cfc:	6867      	ldr	r7, [r4, #4]
    1cfe:	605f      	str	r7, [r3, #4]
    1d00:	68a7      	ldr	r7, [r4, #8]
    1d02:	609f      	str	r7, [r3, #8]
    1d04:	68e7      	ldr	r7, [r4, #12]
    1d06:	3410      	adds	r4, #16
    1d08:	60df      	str	r7, [r3, #12]
    1d0a:	3310      	adds	r3, #16
    1d0c:	429d      	cmp	r5, r3
    1d0e:	d1f3      	bne.n	1cf8 <memcpy+0x20>
    1d10:	230f      	movs	r3, #15
    1d12:	439e      	bics	r6, r3
    1d14:	3610      	adds	r6, #16
    1d16:	1985      	adds	r5, r0, r6
    1d18:	1989      	adds	r1, r1, r6
    1d1a:	4013      	ands	r3, r2
    1d1c:	2b03      	cmp	r3, #3
    1d1e:	d91a      	bls.n	1d56 <memcpy+0x7e>
    1d20:	1f1e      	subs	r6, r3, #4
    1d22:	2300      	movs	r3, #0
    1d24:	08b4      	lsrs	r4, r6, #2
    1d26:	3401      	adds	r4, #1
    1d28:	00a4      	lsls	r4, r4, #2
    1d2a:	58cf      	ldr	r7, [r1, r3]
    1d2c:	50ef      	str	r7, [r5, r3]
    1d2e:	3304      	adds	r3, #4
    1d30:	42a3      	cmp	r3, r4
    1d32:	d1fa      	bne.n	1d2a <memcpy+0x52>
    1d34:	2403      	movs	r4, #3
    1d36:	43a6      	bics	r6, r4
    1d38:	1d33      	adds	r3, r6, #4
    1d3a:	4022      	ands	r2, r4
    1d3c:	18c9      	adds	r1, r1, r3
    1d3e:	18ed      	adds	r5, r5, r3
    1d40:	2a00      	cmp	r2, #0
    1d42:	d005      	beq.n	1d50 <memcpy+0x78>
    1d44:	2300      	movs	r3, #0
    1d46:	5ccc      	ldrb	r4, [r1, r3]
    1d48:	54ec      	strb	r4, [r5, r3]
    1d4a:	3301      	adds	r3, #1
    1d4c:	4293      	cmp	r3, r2
    1d4e:	d1fa      	bne.n	1d46 <memcpy+0x6e>
    1d50:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1d52:	0005      	movs	r5, r0
    1d54:	e7f6      	b.n	1d44 <memcpy+0x6c>
    1d56:	001a      	movs	r2, r3
    1d58:	e7f2      	b.n	1d40 <memcpy+0x68>
    1d5a:	46c0      	nop			; (mov r8, r8)

00001d5c <memset>:
    1d5c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d5e:	0783      	lsls	r3, r0, #30
    1d60:	d043      	beq.n	1dea <memset+0x8e>
    1d62:	1e54      	subs	r4, r2, #1
    1d64:	2a00      	cmp	r2, #0
    1d66:	d03f      	beq.n	1de8 <memset+0x8c>
    1d68:	b2ce      	uxtb	r6, r1
    1d6a:	0002      	movs	r2, r0
    1d6c:	2503      	movs	r5, #3
    1d6e:	e002      	b.n	1d76 <memset+0x1a>
    1d70:	001a      	movs	r2, r3
    1d72:	3c01      	subs	r4, #1
    1d74:	d338      	bcc.n	1de8 <memset+0x8c>
    1d76:	1c53      	adds	r3, r2, #1
    1d78:	7016      	strb	r6, [r2, #0]
    1d7a:	422b      	tst	r3, r5
    1d7c:	d1f8      	bne.n	1d70 <memset+0x14>
    1d7e:	2c03      	cmp	r4, #3
    1d80:	d92a      	bls.n	1dd8 <memset+0x7c>
    1d82:	22ff      	movs	r2, #255	; 0xff
    1d84:	400a      	ands	r2, r1
    1d86:	0215      	lsls	r5, r2, #8
    1d88:	4315      	orrs	r5, r2
    1d8a:	042a      	lsls	r2, r5, #16
    1d8c:	4315      	orrs	r5, r2
    1d8e:	2c0f      	cmp	r4, #15
    1d90:	d914      	bls.n	1dbc <memset+0x60>
    1d92:	0027      	movs	r7, r4
    1d94:	001a      	movs	r2, r3
    1d96:	3f10      	subs	r7, #16
    1d98:	093e      	lsrs	r6, r7, #4
    1d9a:	3601      	adds	r6, #1
    1d9c:	0136      	lsls	r6, r6, #4
    1d9e:	199e      	adds	r6, r3, r6
    1da0:	6015      	str	r5, [r2, #0]
    1da2:	6055      	str	r5, [r2, #4]
    1da4:	6095      	str	r5, [r2, #8]
    1da6:	60d5      	str	r5, [r2, #12]
    1da8:	3210      	adds	r2, #16
    1daa:	4296      	cmp	r6, r2
    1dac:	d1f8      	bne.n	1da0 <memset+0x44>
    1dae:	220f      	movs	r2, #15
    1db0:	4397      	bics	r7, r2
    1db2:	3710      	adds	r7, #16
    1db4:	19db      	adds	r3, r3, r7
    1db6:	4014      	ands	r4, r2
    1db8:	2c03      	cmp	r4, #3
    1dba:	d90d      	bls.n	1dd8 <memset+0x7c>
    1dbc:	001a      	movs	r2, r3
    1dbe:	1f27      	subs	r7, r4, #4
    1dc0:	08be      	lsrs	r6, r7, #2
    1dc2:	3601      	adds	r6, #1
    1dc4:	00b6      	lsls	r6, r6, #2
    1dc6:	199e      	adds	r6, r3, r6
    1dc8:	c220      	stmia	r2!, {r5}
    1dca:	42b2      	cmp	r2, r6
    1dcc:	d1fc      	bne.n	1dc8 <memset+0x6c>
    1dce:	2203      	movs	r2, #3
    1dd0:	4397      	bics	r7, r2
    1dd2:	3704      	adds	r7, #4
    1dd4:	19db      	adds	r3, r3, r7
    1dd6:	4014      	ands	r4, r2
    1dd8:	2c00      	cmp	r4, #0
    1dda:	d005      	beq.n	1de8 <memset+0x8c>
    1ddc:	b2c9      	uxtb	r1, r1
    1dde:	191c      	adds	r4, r3, r4
    1de0:	7019      	strb	r1, [r3, #0]
    1de2:	3301      	adds	r3, #1
    1de4:	429c      	cmp	r4, r3
    1de6:	d1fb      	bne.n	1de0 <memset+0x84>
    1de8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1dea:	0014      	movs	r4, r2
    1dec:	0003      	movs	r3, r0
    1dee:	e7c6      	b.n	1d7e <memset+0x22>

00001df0 <register_fini>:
    1df0:	4b03      	ldr	r3, [pc, #12]	; (1e00 <register_fini+0x10>)
    1df2:	b510      	push	{r4, lr}
    1df4:	2b00      	cmp	r3, #0
    1df6:	d002      	beq.n	1dfe <register_fini+0xe>
    1df8:	4802      	ldr	r0, [pc, #8]	; (1e04 <register_fini+0x14>)
    1dfa:	f000 f805 	bl	1e08 <atexit>
    1dfe:	bd10      	pop	{r4, pc}
    1e00:	00000000 	.word	0x00000000
    1e04:	00001e19 	.word	0x00001e19

00001e08 <atexit>:
    1e08:	b510      	push	{r4, lr}
    1e0a:	0001      	movs	r1, r0
    1e0c:	2300      	movs	r3, #0
    1e0e:	2200      	movs	r2, #0
    1e10:	2000      	movs	r0, #0
    1e12:	f000 f81f 	bl	1e54 <__register_exitproc>
    1e16:	bd10      	pop	{r4, pc}

00001e18 <__libc_fini_array>:
    1e18:	b570      	push	{r4, r5, r6, lr}
    1e1a:	4b09      	ldr	r3, [pc, #36]	; (1e40 <__libc_fini_array+0x28>)
    1e1c:	4c09      	ldr	r4, [pc, #36]	; (1e44 <__libc_fini_array+0x2c>)
    1e1e:	1ae4      	subs	r4, r4, r3
    1e20:	10a4      	asrs	r4, r4, #2
    1e22:	d009      	beq.n	1e38 <__libc_fini_array+0x20>
    1e24:	4a08      	ldr	r2, [pc, #32]	; (1e48 <__libc_fini_array+0x30>)
    1e26:	18a5      	adds	r5, r4, r2
    1e28:	00ad      	lsls	r5, r5, #2
    1e2a:	18ed      	adds	r5, r5, r3
    1e2c:	682b      	ldr	r3, [r5, #0]
    1e2e:	3c01      	subs	r4, #1
    1e30:	4798      	blx	r3
    1e32:	3d04      	subs	r5, #4
    1e34:	2c00      	cmp	r4, #0
    1e36:	d1f9      	bne.n	1e2c <__libc_fini_array+0x14>
    1e38:	f000 f906 	bl	2048 <_fini>
    1e3c:	bd70      	pop	{r4, r5, r6, pc}
    1e3e:	46c0      	nop			; (mov r8, r8)
    1e40:	00002054 	.word	0x00002054
    1e44:	00002058 	.word	0x00002058
    1e48:	3fffffff 	.word	0x3fffffff

00001e4c <__retarget_lock_acquire_recursive>:
    1e4c:	4770      	bx	lr
    1e4e:	46c0      	nop			; (mov r8, r8)

00001e50 <__retarget_lock_release_recursive>:
    1e50:	4770      	bx	lr
    1e52:	46c0      	nop			; (mov r8, r8)

00001e54 <__register_exitproc>:
    1e54:	b5f0      	push	{r4, r5, r6, r7, lr}
    1e56:	464e      	mov	r6, r9
    1e58:	4645      	mov	r5, r8
    1e5a:	46de      	mov	lr, fp
    1e5c:	4657      	mov	r7, sl
    1e5e:	b5e0      	push	{r5, r6, r7, lr}
    1e60:	4d36      	ldr	r5, [pc, #216]	; (1f3c <__register_exitproc+0xe8>)
    1e62:	b083      	sub	sp, #12
    1e64:	0006      	movs	r6, r0
    1e66:	6828      	ldr	r0, [r5, #0]
    1e68:	4698      	mov	r8, r3
    1e6a:	000f      	movs	r7, r1
    1e6c:	4691      	mov	r9, r2
    1e6e:	f7ff ffed 	bl	1e4c <__retarget_lock_acquire_recursive>
    1e72:	4b33      	ldr	r3, [pc, #204]	; (1f40 <__register_exitproc+0xec>)
    1e74:	681c      	ldr	r4, [r3, #0]
    1e76:	23a4      	movs	r3, #164	; 0xa4
    1e78:	005b      	lsls	r3, r3, #1
    1e7a:	58e0      	ldr	r0, [r4, r3]
    1e7c:	2800      	cmp	r0, #0
    1e7e:	d052      	beq.n	1f26 <__register_exitproc+0xd2>
    1e80:	6843      	ldr	r3, [r0, #4]
    1e82:	2b1f      	cmp	r3, #31
    1e84:	dc13      	bgt.n	1eae <__register_exitproc+0x5a>
    1e86:	1c5a      	adds	r2, r3, #1
    1e88:	9201      	str	r2, [sp, #4]
    1e8a:	2e00      	cmp	r6, #0
    1e8c:	d128      	bne.n	1ee0 <__register_exitproc+0x8c>
    1e8e:	9a01      	ldr	r2, [sp, #4]
    1e90:	3302      	adds	r3, #2
    1e92:	009b      	lsls	r3, r3, #2
    1e94:	6042      	str	r2, [r0, #4]
    1e96:	501f      	str	r7, [r3, r0]
    1e98:	6828      	ldr	r0, [r5, #0]
    1e9a:	f7ff ffd9 	bl	1e50 <__retarget_lock_release_recursive>
    1e9e:	2000      	movs	r0, #0
    1ea0:	b003      	add	sp, #12
    1ea2:	bc3c      	pop	{r2, r3, r4, r5}
    1ea4:	4690      	mov	r8, r2
    1ea6:	4699      	mov	r9, r3
    1ea8:	46a2      	mov	sl, r4
    1eaa:	46ab      	mov	fp, r5
    1eac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1eae:	4b25      	ldr	r3, [pc, #148]	; (1f44 <__register_exitproc+0xf0>)
    1eb0:	2b00      	cmp	r3, #0
    1eb2:	d03d      	beq.n	1f30 <__register_exitproc+0xdc>
    1eb4:	20c8      	movs	r0, #200	; 0xc8
    1eb6:	0040      	lsls	r0, r0, #1
    1eb8:	e000      	b.n	1ebc <__register_exitproc+0x68>
    1eba:	bf00      	nop
    1ebc:	2800      	cmp	r0, #0
    1ebe:	d037      	beq.n	1f30 <__register_exitproc+0xdc>
    1ec0:	22a4      	movs	r2, #164	; 0xa4
    1ec2:	2300      	movs	r3, #0
    1ec4:	0052      	lsls	r2, r2, #1
    1ec6:	58a1      	ldr	r1, [r4, r2]
    1ec8:	6043      	str	r3, [r0, #4]
    1eca:	6001      	str	r1, [r0, #0]
    1ecc:	50a0      	str	r0, [r4, r2]
    1ece:	3240      	adds	r2, #64	; 0x40
    1ed0:	5083      	str	r3, [r0, r2]
    1ed2:	3204      	adds	r2, #4
    1ed4:	5083      	str	r3, [r0, r2]
    1ed6:	3301      	adds	r3, #1
    1ed8:	9301      	str	r3, [sp, #4]
    1eda:	2300      	movs	r3, #0
    1edc:	2e00      	cmp	r6, #0
    1ede:	d0d6      	beq.n	1e8e <__register_exitproc+0x3a>
    1ee0:	009a      	lsls	r2, r3, #2
    1ee2:	4692      	mov	sl, r2
    1ee4:	4482      	add	sl, r0
    1ee6:	464a      	mov	r2, r9
    1ee8:	2188      	movs	r1, #136	; 0x88
    1eea:	4654      	mov	r4, sl
    1eec:	5062      	str	r2, [r4, r1]
    1eee:	22c4      	movs	r2, #196	; 0xc4
    1ef0:	0052      	lsls	r2, r2, #1
    1ef2:	4691      	mov	r9, r2
    1ef4:	4481      	add	r9, r0
    1ef6:	464a      	mov	r2, r9
    1ef8:	3987      	subs	r1, #135	; 0x87
    1efa:	4099      	lsls	r1, r3
    1efc:	6812      	ldr	r2, [r2, #0]
    1efe:	468b      	mov	fp, r1
    1f00:	430a      	orrs	r2, r1
    1f02:	4694      	mov	ip, r2
    1f04:	464a      	mov	r2, r9
    1f06:	4661      	mov	r1, ip
    1f08:	6011      	str	r1, [r2, #0]
    1f0a:	2284      	movs	r2, #132	; 0x84
    1f0c:	4641      	mov	r1, r8
    1f0e:	0052      	lsls	r2, r2, #1
    1f10:	50a1      	str	r1, [r4, r2]
    1f12:	2e02      	cmp	r6, #2
    1f14:	d1bb      	bne.n	1e8e <__register_exitproc+0x3a>
    1f16:	0002      	movs	r2, r0
    1f18:	465c      	mov	r4, fp
    1f1a:	328d      	adds	r2, #141	; 0x8d
    1f1c:	32ff      	adds	r2, #255	; 0xff
    1f1e:	6811      	ldr	r1, [r2, #0]
    1f20:	430c      	orrs	r4, r1
    1f22:	6014      	str	r4, [r2, #0]
    1f24:	e7b3      	b.n	1e8e <__register_exitproc+0x3a>
    1f26:	0020      	movs	r0, r4
    1f28:	304d      	adds	r0, #77	; 0x4d
    1f2a:	30ff      	adds	r0, #255	; 0xff
    1f2c:	50e0      	str	r0, [r4, r3]
    1f2e:	e7a7      	b.n	1e80 <__register_exitproc+0x2c>
    1f30:	6828      	ldr	r0, [r5, #0]
    1f32:	f7ff ff8d 	bl	1e50 <__retarget_lock_release_recursive>
    1f36:	2001      	movs	r0, #1
    1f38:	4240      	negs	r0, r0
    1f3a:	e7b1      	b.n	1ea0 <__register_exitproc+0x4c>
    1f3c:	20000438 	.word	0x20000438
    1f40:	00002030 	.word	0x00002030
    1f44:	00000000 	.word	0x00000000
    1f48:	65636552 	.word	0x65636552
    1f4c:	64657669 	.word	0x64657669
    1f50:	0a642520 	.word	0x0a642520
    1f54:	00000000 	.word	0x00000000
    1f58:	6c696146 	.word	0x6c696146
    1f5c:	74206465 	.word	0x74206465
    1f60:	6572206f 	.word	0x6572206f
    1f64:	76696563 	.word	0x76696563
    1f68:	61642065 	.word	0x61642065
    1f6c:	66206174 	.word	0x66206174
    1f70:	206d6f72 	.word	0x206d6f72
    1f74:	75657571 	.word	0x75657571
    1f78:	00000a65 	.word	0x00000a65
    1f7c:	646e6553 	.word	0x646e6553
    1f80:	20642520 	.word	0x20642520
    1f84:	72206f74 	.word	0x72206f74
    1f88:	69656365 	.word	0x69656365
    1f8c:	20726576 	.word	0x20726576
    1f90:	6b736174 	.word	0x6b736174
    1f94:	0000000a 	.word	0x0000000a
    1f98:	6c65480a 	.word	0x6c65480a
    1f9c:	57206f6c 	.word	0x57206f6c
    1fa0:	646c726f 	.word	0x646c726f
    1fa4:	73617420 	.word	0x73617420
    1fa8:	2031206b 	.word	0x2031206b
    1fac:	00006425 	.word	0x00006425
    1fb0:	000a5055 	.word	0x000a5055
    1fb4:	4e574f44 	.word	0x4e574f44
    1fb8:	0000000a 	.word	0x0000000a
    1fbc:	5446454c 	.word	0x5446454c
    1fc0:	0000000a 	.word	0x0000000a
    1fc4:	48474952 	.word	0x48474952
    1fc8:	00000a54 	.word	0x00000a54
    1fcc:	646e6573 	.word	0x646e6573
    1fd0:	00007265 	.word	0x00007265
    1fd4:	65636572 	.word	0x65636572
    1fd8:	72657669 	.word	0x72657669
    1fdc:	00000000 	.word	0x00000000
    1fe0:	454c4449 	.word	0x454c4449
    1fe4:	00000000 	.word	0x00000000
    1fe8:	09632509 	.word	0x09632509
    1fec:	25097525 	.word	0x25097525
    1ff0:	75250975 	.word	0x75250975
    1ff4:	00000a0d 	.word	0x00000a0d
    1ff8:	00001b60 	.word	0x00001b60
    1ffc:	00001b60 	.word	0x00001b60
    2000:	00001b60 	.word	0x00001b60
    2004:	00001ad8 	.word	0x00001ad8
    2008:	00001ba2 	.word	0x00001ba2
    200c:	00001bbc 	.word	0x00001bbc
    2010:	00001b60 	.word	0x00001b60
    2014:	00001b60 	.word	0x00001b60
    2018:	00001ad8 	.word	0x00001ad8
    201c:	00001ba2 	.word	0x00001ba2
    2020:	51726d54 	.word	0x51726d54
    2024:	00000000 	.word	0x00000000
    2028:	20726d54 	.word	0x20726d54
    202c:	00637653 	.word	0x00637653

00002030 <_global_impure_ptr>:
    2030:	20000010                                ... 

00002034 <_init>:
    2034:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2036:	46c0      	nop			; (mov r8, r8)
    2038:	bcf8      	pop	{r3, r4, r5, r6, r7}
    203a:	bc08      	pop	{r3}
    203c:	469e      	mov	lr, r3
    203e:	4770      	bx	lr

00002040 <__init_array_start>:
    2040:	00001df1 	.word	0x00001df1

00002044 <__frame_dummy_init_array_entry>:
    2044:	000000dd                                ....

00002048 <_fini>:
    2048:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    204a:	46c0      	nop			; (mov r8, r8)
    204c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    204e:	bc08      	pop	{r3}
    2050:	469e      	mov	lr, r3
    2052:	4770      	bx	lr

00002054 <__fini_array_start>:
    2054:	000000b5 	.word	0x000000b5
